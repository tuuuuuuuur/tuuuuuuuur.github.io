<!DOCTYPE html>

<html lang="zh-CN" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="Python 2.2 有什么新变化" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/whatsnew/2.2.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="作者, A.M. Kuchling,. 概述: 本文本介绍了 Python 2.2.2 的新增特性，该版本发布于 2002 年 10 月 14日。 Python 2.2.2 是 Python 2.2 的问题修正发布版，最初发布于 2001 年 12 月 21 日。 Python 2.2 可以被看作是 &quot;清理发布版&quot;。 有一些特性如生成器和迭代器等是全新的，但大多数变化，尽管可能是重大而深远的..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="作者, A.M. Kuchling,. 概述: 本文本介绍了 Python 2.2.2 的新增特性，该版本发布于 2002 年 10 月 14日。 Python 2.2.2 是 Python 2.2 的问题修正发布版，最初发布于 2001 年 12 月 21 日。 Python 2.2 可以被看作是 &quot;清理发布版&quot;。 有一些特性如生成器和迭代器等是全新的，但大多数变化，尽管可能是重大而深远的..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>Python 2.2 有什么新变化 &#8212; Python 3.14.0a4 文档</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=08c2cdb3" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=5349f25f" />
    
    <script src="../_static/documentation_options.js?v=495aad30"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=beaddf03"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.14.0a4 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于此文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权所有" href="../copyright.html" />
    <link rel="next" title="Python 2.1 有什么新变化" href="2.1.html" />
    <link rel="prev" title="Python 2.3 有什么新变化" href="2.3.html" />
    
      <script defer data-domain="docs.python.org" src="https://plausible.io/js/script.js"></script>
    
    <link rel="canonical" href="https://docs.python.org/3/whatsnew/2.2.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q" />
                <input type="submit" value="提交"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#">Python 2.2 有什么新变化</a><ul>
<li><a class="reference internal" href="#introduction">概述</a></li>
<li><a class="reference internal" href="#peps-252-and-253-type-and-class-changes">PEP 252 和 253：类型和类的修改</a><ul>
<li><a class="reference internal" href="#old-and-new-classes">旧式类和新式类</a></li>
<li><a class="reference internal" href="#descriptors">描述器</a></li>
<li><a class="reference internal" href="#multiple-inheritance-the-diamond-rule">多重继承：钻石规则</a></li>
<li><a class="reference internal" href="#attribute-access">属性访问</a></li>
<li><a class="reference internal" href="#related-links">相关链接</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pep-234-iterators">PEP 234: 迭代器</a></li>
<li><a class="reference internal" href="#pep-255-simple-generators">PEP 255: 简单的生成器</a></li>
<li><a class="reference internal" href="#pep-237-unifying-long-integers-and-integers">PEP 237: 统一长整数和整数</a></li>
<li><a class="reference internal" href="#pep-238-changing-the-division-operator">PEP 238：修改除法运算符</a></li>
<li><a class="reference internal" href="#unicode-changes">Unicode 的改变</a></li>
<li><a class="reference internal" href="#pep-227-nested-scopes">PEP 227: 嵌套的作用域</a></li>
<li><a class="reference internal" href="#new-and-improved-modules">新增和改进的模块</a></li>
<li><a class="reference internal" href="#interpreter-changes-and-fixes">解释器的改变和修正</a></li>
<li><a class="reference internal" href="#other-changes-and-fixes">其他的改变和修正</a></li>
<li><a class="reference internal" href="#acknowledgements">致谢</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一主题</h4>
    <p class="topless"><a href="2.3.html"
                          title="上一章">Python 2.3 有什么新变化</a></p>
  </div>
  <div>
    <h4>下一主题</h4>
    <p class="topless"><a href="2.1.html"
                          title="下一章">Python 2.1 有什么新变化</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/whatsnew/2.2.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="2.1.html" title="Python 2.1 有什么新变化"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="2.3.html" title="Python 2.3 有什么新变化"
             accesskey="P">上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.14.0a4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python的新变化</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Python 2.2 有什么新变化</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q" id="search-box" />
          <input type="submit" value="提交" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="what-s-new-in-python-2-2">
<h1>Python 2.2 有什么新变化<a class="headerlink" href="#what-s-new-in-python-2-2" title="Link to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">作者<span class="colon">:</span></dt>
<dd class="field-odd"><p>A.M. Kuchling</p>
</dd>
</dl>
<section id="introduction">
<h2>概述<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>本文本介绍了 Python 2.2.2 的新增特性，该版本发布于 2002 年 10 月 14日。 Python 2.2.2 是 Python 2.2 的问题修正发布版，最初发布于 2001 年 12 月 21 日。</p>
<p>Python 2.2 可以被看作是 &quot;清理发布版&quot;。 有一些特性如生成器和迭代器等是全新的，但大多数变化，尽管可能是重大而深远的，都是为了清理语言设计中的不规范和阴暗角落。</p>
<p>本文并不试图提供对新特性的完整规范说明，而是提供一个便捷的概览。 要获取全部细节，你应该参阅 Python 2.2 的文档，比如 <a class="reference external" href="https://docs.python.org/2.2/lib/lib.html">Python 库参考</a> 和 <a class="reference external" href="https://docs.python.org/2.2/ref/ref.html">Python 参考指南</a>。 如果你想要了解某项更改的完整实现和设计理念，请参阅特定新特性的 PEP。</p>
</section>
<section id="peps-252-and-253-type-and-class-changes">
<h2>PEP 252 和 253：类型和类的修改<a class="headerlink" href="#peps-252-and-253-type-and-class-changes" title="Link to this heading">¶</a></h2>
<p>Python 2.2 中最大且影响最深远的改变是针对 Python 的对象和类模型。 这些变化应该是向下兼容的，因此你的代码将能继续运行而无需修改，但这些变化提供了一些很棒的新功能。 在开始本文最长和最复杂的部分之前，我提供对这些变化的概览并附带一些注释。</p>
<p>很久以前我写过一个网页来列出 Python 设计中的一些缺陷。 其中一个最明显的缺陷是无法子类化用 C 实现的 Python 类型。 具体来说，内置类型是无法子类化的，例如你不能简单地子类化列表以便向其添加一个有用的方法。 虽然 <code class="xref py py-mod docutils literal notranslate"><span class="pre">UserList</span></code> 模块提供了一个支持所有列表方法的类并且可以进一步子类化，但有很多 C 代码都期望一个常规的 Python 列表而不能接受 <a class="reference internal" href="../library/collections.html#collections.UserList" title="collections.UserList"><code class="xref py py-class docutils literal notranslate"><span class="pre">UserList</span></code></a> 实例。</p>
<p>Python 2.2 修正了此问题，并在此过程中添加了一些令人激动的新功能。 简明概述如下:</p>
<ul class="simple">
<li><p>你可以继承内置类型，例如列表和整数，并且你的子类应该在任何需要原始类型的地方正常工作。这使得 Python 的面向对象编程更加灵活和强大。</p></li>
<li><p>现在，除了之前版本的 Python 中可用的实例方法外，还可以定义静态方法和类方法。这使得你可以更灵活地组织类的行为。</p></li>
<li><p>另一种可能的做法是通过使用名为 <em class="dfn">特征属性</em> 的机制在访问或设置实例属性时自动调用方法。 许多 <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 的用法可以被重写为改用特征属性，使得结果代码更简单且更快速。 作为一个小小的附带好处，现在属性也可以带有文档字符串。</p></li>
<li><p>可以使用 __slots__ 限制实例的合法属性列表，从而防止拼写错误，并且在未来的 Python 版本中可能进行更多的优化。</p></li>
</ul>
<p>一些用户对这些变化表示担忧。确实，他们说，新功能很棒，可以实现以前版本的 Python 无法做到的各种技巧，但它们也使语言变得更加复杂。一些人表示，他们一直推荐 Python 是因为它的简单性，现在感觉这种简单性正在丧失。</p>
<p>个人而言，我认为没有必要担心。许多新功能相当深奥，你可以编写大量 Python 代码而不需要了解它们。编写一个简单的类并不比以前更难，因此除非确实需要，否则你不必费心去学习或教授这些新功能。一些以前只有在 C 语言中才能实现的非常复杂的任务，现在可以用纯 Python 实现，在我看来，这一切都更好了。</p>
<p>我不会尝试涵盖所有为了使新功能生效而需要的每一个边缘情况和小改动。相反，本节将只勾勒出大致的轮廓。有关 Python 2.2 新对象模型的更多信息，请参见 <a class="reference internal" href="#sect-rellinks"><span class="std std-ref">相关链接</span></a> 的“相关链接”部分。</p>
<section id="old-and-new-classes">
<h3>旧式类和新式类<a class="headerlink" href="#old-and-new-classes" title="Link to this heading">¶</a></h3>
<p>首先，你应该知道 Python 2.2 实际上有两种类型的类：经典类（或旧式类）和新式类。旧式类模型与早期版本的 Python 中的类模型完全相同。本节描述的所有新功能仅适用于新式类。这种分歧并不是永久的；最终，旧式类将被淘汰，可能在 Python 3.0 中被移除。</p>
<p>那么如何定义一个新式类呢？你可以通过继承一个现有的新式类来实现。大多数 Python 内置类型，如整数、列表、字典，甚至文件，现在都是新式类。此外，还添加了一个名为 <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 的新式类，它是所有内置类型的基类，因此如果没有合适的内置类型，你可以直接继承 <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 类：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>这意味着在 Python 2.2 中不带任何基类的 <a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">class</span></code></a> 语句总是属于经典类。 （实际上你也可以通过设置一个名为 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__metaclass__</span></code> 的模块级变量来改变这一点 —— 详见 <span class="target" id="index-46"></span><a class="pep reference external" href="https://peps.python.org/pep-0253/"><strong>PEP 253</strong></a> —— 但更简单的做法是直接子类化 <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>。）</p>
<p>内置类型的类型对象在 Python 2.2 中作为内置对象提供，使用了一种巧妙的技巧命名。Python 一直有名为 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a>、<a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a> 和 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 的内置函数。在 Python 2.2 中，它们不再是函数，而是作为被调用时表现为工厂的类型对象。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span>
<span class="go">&lt;type &#39;int&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="s1">&#39;123&#39;</span><span class="p">)</span>
<span class="go">123</span>
</pre></div>
</div>
<p>为了使类型集合更为完备，增加了新的类型对象如 <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-func docutils literal notranslate"><span class="pre">dict()</span></code></a> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">file()</span></code>。 下面是一个更有趣的示例，向文件对象添加一个 <code class="xref py py-meth docutils literal notranslate"><span class="pre">lock()</span></code> 方法:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">LockableFile</span><span class="p">(</span><span class="n">file</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">lock</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operation</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">whence</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">fcntl</span>
        <span class="k">return</span> <span class="n">fcntl</span><span class="o">.</span><span class="n">lockf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="n">operation</span><span class="p">,</span>
                           <span class="n">length</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">whence</span><span class="p">)</span>
</pre></div>
</div>
<p>现在已经过时的 <code class="xref py py-mod docutils literal notranslate"><span class="pre">posixfile</span></code> 模块包含一个类，该类模仿了文件对象的所有方法，并添加了一个 <code class="xref py py-meth docutils literal notranslate"><span class="pre">lock()</span></code> 方法，但这个类不能传递给期望内置文件对象的内部函数，而这在我们的新 <code class="xref py py-class docutils literal notranslate"><span class="pre">LockableFile</span></code> 实现中是可能的。</p>
</section>
<section id="descriptors">
<h3>描述器<a class="headerlink" href="#descriptors" title="Link to this heading">¶</a></h3>
<p>在以前的 Python 版本中，没有一致的方式来发现对象支持的属性和方法。 有一些非正式的约定，例如定义 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__members__</span></code> 和 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__methods__</span></code> 属性，这些属性是名称列表，但扩展类型或类的作者往往不会去定义它们。 你可以回退到检查对象的 <a class="reference internal" href="../reference/datamodel.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 属性，但在使用类继承或任意的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code> 钩子时，这仍然可能是不准确的。</p>
<p>新类模型的一个核心理念是正式化了使用描述符来描述对象属性的 API。描述符指定属性的值，说明它是方法还是字段。通过描述符 API，静态方法和类方法成为可能，以及其他更复杂的构造。</p>
<p>属性描述符是存在于类对象内部的对象，它们自身具有一些属性。描述符协议由三个主要方法组成：</p>
<ul class="simple">
<li><p><a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> 是属性的名称。</p></li>
<li><p><a class="reference internal" href="../library/stdtypes.html#definition.__doc__" title="definition.__doc__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code></a> 是属性的文档字符串。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__get__(object)</span></code> 是一个从 <em>object</em> 中提取属性值的方法。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__set__(object,</span> <span class="pre">value)</span></code> 将 <em>object</em> 上的属性设为 <em>value</em>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__delete__(object,</span> <span class="pre">value)</span></code> 将删除 <em>object</em> 的 <em>value</em> 属性。</p></li>
</ul>
<p>例如，当你写下 <code class="docutils literal notranslate"><span class="pre">obj.x</span></code>，Python 实际要执行的步骤是:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">x</span>
<span class="n">descriptor</span><span class="o">.</span><span class="fm">__get__</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
</pre></div>
</div>
<p>对于方法，<a class="reference internal" href="../reference/datamodel.html#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">descriptor.__get__</span></code></a> 返回一个可调用的临时对象，它将实例和要调用的方法包装在一起。 这也是为什么现在可以实现静态方法和类方法的原因；它们有只包装方法或者类的描述器。 作为对这些新方法类别的简要说明，静态方法不传递实例，因此类似于常规函数。 类方法将传递对象的类，但不是对象本身。 静态方法和类方法是这样定义的:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">):</span>
        <span class="o">...</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">g</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">):</span>
        <span class="o">...</span>
    <span class="n">g</span> <span class="o">=</span> <span class="nb">classmethod</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a> 函数接收函数 <code class="xref py py-func docutils literal notranslate"><span class="pre">f()</span></code>，并将其封装在描述符中返回，这样它就可以存储在类对象中。 您可能希望有特殊的语法来创建这样的方法 (<code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">static</span> <span class="pre">f</span></code> , <code class="docutils literal notranslate"><span class="pre">defstatic</span> <span class="pre">f()</span></code> 或类似的东西)，但目前还没有定义这样的语法；这要留待 Python 的未来版本去解决。</p>
<p>更多的新功能，如 __slots__ 和属性，也作为新类型的描述符实现。编写一个实现新功能的描述符类并不困难。例如，可以编写一个描述符类，使其能够为方法编写类似 Eiffel 风格的前置条件和后置条件。使用该功能的类可能定义如下：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">eiffel</span><span class="w"> </span><span class="kn">import</span> <span class="n">eiffelmethod</span>

<span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">):</span>
        <span class="c1"># 实际的函数</span>
        <span class="o">...</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">pre_f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 检查先决条件</span>
        <span class="o">...</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">post_f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 检查后置条件</span>
        <span class="o">...</span>

    <span class="n">f</span> <span class="o">=</span> <span class="n">eiffelmethod</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">pre_f</span><span class="p">,</span> <span class="n">post_f</span><span class="p">)</span>
</pre></div>
</div>
<p>请注意，使用新 <code class="xref py py-func docutils literal notranslate"><span class="pre">eiffelmethod()</span></code> 的人不必了解任何关于描述器的知识。 这就是我认为新功能不会增加语言基本复杂性的原因。 会有一些向导需要了解它，以便编写 <code class="xref py py-func docutils literal notranslate"><span class="pre">eiffelmethod()</span></code> 或 ZODB 或其他内容，但大多数用户只会在生成的库之上编写代码，而会忽略其实现细节。</p>
</section>
<section id="multiple-inheritance-the-diamond-rule">
<h3>多重继承：钻石规则<a class="headerlink" href="#multiple-inheritance-the-diamond-rule" title="Link to this heading">¶</a></h3>
<p>通过改变名称解析规则，多重继承也变得更加有用。  请看下面这组类（图表摘自 <span class="target" id="index-47"></span><a class="pep reference external" href="https://peps.python.org/pep-0253/"><strong>PEP 253</strong></a> ，作者 Guido van Rossum）：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span>      <span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="p">:</span>
        <span class="o">^</span> <span class="o">^</span>  <span class="k">def</span><span class="w"> </span><span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="o">...</span>
       <span class="o">/</span>   \
      <span class="o">/</span>     \
     <span class="o">/</span>       \
    <span class="o">/</span>         \
<span class="k">class</span><span class="w"> </span><span class="nc">B</span>     <span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">:</span>
    <span class="o">^</span>         <span class="o">^</span>  <span class="k">def</span><span class="w"> </span><span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="o">...</span>
     \       <span class="o">/</span>
      \     <span class="o">/</span>
       \   <span class="o">/</span>
        \ <span class="o">/</span>
      <span class="k">class</span><span class="w"> </span><span class="nc">D</span>
</pre></div>
</div>
<p>经典类的查找规则很简单，但并不高明；基类的查找是深度优先的，从左到右依次查找。 对 <code class="xref py py-meth docutils literal notranslate"><span class="pre">D.save()</span></code> 的引用将搜索类 <code class="xref py py-class docutils literal notranslate"><span class="pre">D</span></code>、<code class="xref py py-class docutils literal notranslate"><span class="pre">B</span></code>，然后是 <code class="xref py py-class docutils literal notranslate"><span class="pre">A</span></code>，其中 <code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code> 将被找到并返回。 <code class="xref py py-meth docutils literal notranslate"><span class="pre">C.save()</span></code> 根本不会被找到。 这很糟糕，因为如果 <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> 的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code> 方法正在保存 <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> 特有的某些内部状态，不调用该方法将导致该状态永远不会被保存。</p>
<p>新式类遵循一种不同的算法，虽然解释起来有点复杂，但在这种情况下能做正确的事情。（请注意，Python 2.3 改变了这个算法，在大多数情况下会产生相同的结果，但对于非常复杂的继承图会产生更有用的结果。）</p>
<ol class="arabic simple">
<li><p>按照经典的查找规则列出所有基类，如果一个类被重复访问，则将其包含多次。 在上例中，已访问过的类列表为 [<code class="xref py py-class docutils literal notranslate"><span class="pre">D</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">B</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">A</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">A</span></code>]。</p></li>
<li><p>扫描列表来查找重复的类。 如果发现有重复的类，则删除所有重复的类，只留下列表中*后一个。 在上例中，删除重复后的列表变成 [<code class="xref py py-class docutils literal notranslate"><span class="pre">D</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">B</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">A</span></code>]。</p></li>
</ol>
<p>根据这条规则，引用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">D.save()</span></code> 将返回 <code class="xref py py-meth docutils literal notranslate"><span class="pre">C.save()</span></code>，这正是我们想要的行为。 这一查找规则与 Common Lisp 遵循的规则相同。 新的内置函数 <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 提供了一种无需重新实现 Python 算法就能获取类的超类的方法。 最常用的形式是 <code class="docutils literal notranslate"><span class="pre">super(class,</span> <span class="pre">obj)</span></code> ，它返回一个绑定的超类对象（而不是实际的类对象）。 这种形式将用于调用超类中的方法；例如，<code class="xref py py-class docutils literal notranslate"><span class="pre">D</span></code> 的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code> 方法看起来像这样:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">D</span> <span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">C</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">save</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 调用超类的 .save()</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
        <span class="c1"># 在此保存 D 的私有信息</span>
        <span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 在以 <code class="docutils literal notranslate"><span class="pre">super(class)</span></code> 或 <code class="docutils literal notranslate"><span class="pre">super(class1,</span> <span class="pre">class2)</span></code> 形式调用时也可以返回未绑定的超类对象，但这可能并不常用。</p>
</section>
<section id="attribute-access">
<h3>属性访问<a class="headerlink" href="#attribute-access" title="Link to this heading">¶</a></h3>
<p>许多高级的 Python 类通过 <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 定义属性访问钩子；通常这样做是为了方便，通过自动将诸如 <code class="docutils literal notranslate"><span class="pre">obj.parent</span></code> 这样的属性访问映射到诸如 <code class="docutils literal notranslate"><span class="pre">obj.get_parent</span></code> 这样的方法调用，使代码更具可读性。 Python 2.2 添加了一些新的方法来控制属性访问。</p>
<p>首先，新式类仍然支持 <code class="docutils literal notranslate"><span class="pre">__getattr__(attr_name)</span></code>，关于它的任何内容都没有改变。  和以前一样，当试图访问 <code class="docutils literal notranslate"><span class="pre">obj.foo</span></code> 时，如果在实例的字典中找不到名为 <code class="docutils literal notranslate"><span class="pre">foo</span></code> 的属性，就会调用它。</p>
<p>新式类还支持一种新方法 <code class="docutils literal notranslate"><span class="pre">__getattribute__(attr_name)</span></code>。 这两个方法的区别在于 <a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> 在访问任何属性时 <em>总是</em> 被调用，而旧的 <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 仅在 <code class="docutils literal notranslate"><span class="pre">foo</span></code> 未在实例的字典中找到时才被调用。</p>
<p>然而，Python 2.2 对 <em class="dfn">properties</em> 的支持通常是捕获属性引用的更简单方法。 编写 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code> 方法非常复杂，因为为了避免递归，你不能在其中使用常规的属性访问，而是不得不处理 <a class="reference internal" href="../reference/datamodel.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 的内容。 此外，<a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 方法在 Python 检查其他例如 <a class="reference internal" href="../reference/datamodel.html#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> 或 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__coerce__()</span></code> 等方法时也会被调用，因此在编写时需要考虑这些情况。最后，每次属性访问都调用一个函数会导致显著的性能损失。</p>
<p><a class="reference internal" href="../library/functions.html#property" title="property"><code class="xref py py-class docutils literal notranslate"><span class="pre">property</span></code></a> 是一种新的内置类型，它打包了三个用于获取、设置或删除属性的函数，以及一个文档字符串。例如，如果你想定义一个计算得出的属性 <code class="xref py py-attr docutils literal notranslate"><span class="pre">size</span></code>，同时又希望这个属性是可设置的，你可以这样写:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_size</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="o">...</span> <span class="n">执行计算</span> <span class="o">...</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_size</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="o">...</span> <span class="n">基于</span> <span class="n">size</span> <span class="n">进行计算</span>
        <span class="n">并相应地设置内部状态</span> <span class="o">...</span>

    <span class="c1"># 定义一个 property。</span>
    <span class="c1"># 其中 &#39;delete this attribute&#39; 被定义为 None，</span>
    <span class="c1"># 因此该属性不可被删除。</span>
    <span class="n">size</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">get_size</span><span class="p">,</span> <span class="n">set_size</span><span class="p">,</span>
                    <span class="kc">None</span><span class="p">,</span>
                    <span class="s2">&quot;Storage size of this instance&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>这确实比编写一对 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code> / <code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code> 方法要清晰和容易得多，后者需要检查 <code class="xref py py-attr docutils literal notranslate"><span class="pre">size</span></code> 属性并在检索 <a class="reference internal" href="../reference/datamodel.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 的所有其他属性时进行特殊处理。 对 <code class="xref py py-attr docutils literal notranslate"><span class="pre">size</span></code> 属性的访问是唯一需要执行调用函数工作的访问，因此对其他属性的引用仍然以通常的速度运行。</p>
<p>最后，可以使用新的类属性 <a class="reference internal" href="../reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a> 来限制对象上可以引用的属性列表。Python 对象通常非常动态，可以随时通过简单地 <code class="docutils literal notranslate"><span class="pre">obj.new_attr=1</span></code> 来定义一个新属性。新式类可以定义一个名为 <a class="reference internal" href="../reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a> 的类属性，以将合法属性限制为特定的一组名称。一个例子可以更清楚地说明这一点：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;template&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">obj</span><span class="o">.</span><span class="n">template</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">template</span> <span class="o">=</span> <span class="s1">&#39;Test&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">obj</span><span class="o">.</span><span class="n">template</span>
<span class="go">Test</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">newattr</span> <span class="o">=</span> <span class="kc">None</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;C&#39; object has no attribute &#39;newattr&#39;</span>
</pre></div>
</div>
<p>注意，当尝试为未列在 <a class="reference internal" href="../reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a> 中的属性赋值时，会引发 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>。</p>
</section>
<section id="related-links">
<span id="sect-rellinks"></span><h3>相关链接<a class="headerlink" href="#related-links" title="Link to this heading">¶</a></h3>
<p>本节只是对新特性进行了简要概述，提供了足够的解释以帮助你开始编程，但许多细节已被简化或忽略。想要获得更全面的了解，你可以去哪里呢？</p>
<p><a class="reference internal" href="../howto/descriptor.html#descriptorhowto"><span class="std std-ref">描述器指南</span></a> 是由 Guido van Rossum 编写的一篇介绍描述器特性详细教程。 如果我的描述激起了你的兴趣，请继续阅读这篇教程，因为它更加详细地介绍了这些新功能，同时仍然保持了相当的易读性。</p>
<p>接下来，有两个相关的 PEP，即 <span class="target" id="index-48"></span><a class="pep reference external" href="https://peps.python.org/pep-0252/"><strong>PEP 252</strong></a> 和 <span class="target" id="index-49"></span><a class="pep reference external" href="https://peps.python.org/pep-0253/"><strong>PEP 253</strong></a>。<span class="target" id="index-50"></span><a class="pep reference external" href="https://peps.python.org/pep-0252/"><strong>PEP 252</strong></a> 标题为“使类型更像类”，涵盖了描述符 API。<span class="target" id="index-51"></span><a class="pep reference external" href="https://peps.python.org/pep-0253/"><strong>PEP 253</strong></a> 标题为“内置类型的子类型化”，描述了使内置对象可以进行子类型化的类型对象的更改。<span class="target" id="index-52"></span><a class="pep reference external" href="https://peps.python.org/pep-0253/"><strong>PEP 253</strong></a> 是这两个 PEP 中更复杂的一个，在某些点上，必要的类型和元类型解释可能会让人感到头疼。两个 PEP 都由 Guido van Rossum 编写和实现，并得到了 Zope Corp. 团队其他成员的实质性协助。</p>
<p>最后，还有最终的权威来源：源代码。大部分类型处理的机制都在 <code class="file docutils literal notranslate"><span class="pre">Objects/typeobject.c</span></code> 中，但只有在所有其他途径都用尽之后，包括在 python-list 或 python-dev 上发布问题后，才应求助于源代码。</p>
</section>
</section>
<section id="pep-234-iterators">
<h2>PEP 234: 迭代器<a class="headerlink" href="#pep-234-iterators" title="Link to this heading">¶</a></h2>
<p>Python 2.2 的另一个重要新增功能是在 C 和 Python 两个层面上引入了迭代接口。对象可以定义如何被调用者循环遍历。</p>
<p>在 Python 2.1 及之前的版本中，使 <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">obj</span></code> 语句生效的常用方法是定义一个类似于下面的 <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 方法：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
    <span class="k">return</span> <span class="o">&lt;</span><span class="nb">next</span> <span class="n">item</span><span class="o">&gt;</span>
</pre></div>
</div>
<p><a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 更适用于在对象上定义索引操作，以便你可以编写 <code class="docutils literal notranslate"><span class="pre">obj[5]</span></code> 来检索第六个元素。 如果仅仅为了支持 <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 循环而使用它，会有些误导。 考虑一个类文件对象，它希望被循环遍历；<em>index</em> 参数基本上是没有意义的，因为类可能假定会有一系列的 <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 调用，每次 <em>index</em> 增加一。换句话说，<a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 方法的存在并不意味着使用 <code class="docutils literal notranslate"><span class="pre">file[5]</span></code> 随机访问第六个元素是可行的，尽管实际上它应该是可行的。</p>
<p>在 Python 2.2 中，可以单独实现迭代，而 <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 方法可以仅限于真正支持随机访问的类。 迭代器的基本概念很简单。 一个新的内置函数 <code class="docutils literal notranslate"><span class="pre">iter(obj)</span></code> 或 <code class="docutils literal notranslate"><span class="pre">iter(C,</span> <span class="pre">sentinel)</span></code> 被引入，用于获取迭代器。 <code class="docutils literal notranslate"><span class="pre">iter(obj)</span></code> 返回对象 <em>obj</em> 的迭代器，而 <code class="docutils literal notranslate"><span class="pre">iter(C,</span> <span class="pre">sentinel)</span></code> 返回一个迭代器，该迭代器将调用可调用对象 <em>C</em>，直到它返回 <em>sentinel</em>，以此表示迭代结束。</p>
<p>Python 类可以定义一个 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code> 方法，该方法应该创建并返回一个对象的新迭代器；如果对象本身就是它自己的迭代器，这个方法可以简单地返回 <code class="docutils literal notranslate"><span class="pre">self</span></code>。 特别地，迭代器通常会是它们自己的迭代器。 用 C 实现的扩展类型可以实现一个 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_iter</span></code></a> 函数来返回一个迭代器，想要表现为迭代器的扩展类型可以定义一个 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iternext" title="PyTypeObject.tp_iternext"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_iternext</span></code></a> 函数。</p>
<p>总结一下，迭代器实际上做什么？它们有一个必需的方法 <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-meth docutils literal notranslate"><span class="pre">next()</span></code></a>，该方法不接受任何参数并返回下一个值。当没有更多的值可以返回时，调用 <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-meth docutils literal notranslate"><span class="pre">next()</span></code></a> 应该引发 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 异常。以下是一个简单的例子来说明迭代器的工作原理：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">i</span>
<span class="go">&lt;iterator object at 0x8116870&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
<span class="gr">StopIteration</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在 Python 2.2 中，<a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 语句不再期望一个序列；它期望的是一个可以返回迭代器的 <a class="reference internal" href="../library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> 对象。 为了向下兼容和方便，对于那些没有实现 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code> 或 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_iter</span></code></a> 方法的序列，会自动构造一个迭代器，因此 <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">[1,2,3]</span></code> 仍然可以正常工作。 Python 解释器在循环遍历序列时，已经改为使用迭代器协议。 这意味着你可以做类似这样的事情：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">i</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span>
<span class="go">(1, 2, 3)</span>
</pre></div>
</div>
<p>迭代器支持已被添加到Python的一些基本类型中。对字典调用 <a class="reference internal" href="../library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> 会返回一个迭代器，该迭代器遍历字典的键，如下所示：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Jan&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Feb&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;Mar&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;Apr&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;May&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;Jun&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
<span class="gp">... </span>     <span class="s1">&#39;Jul&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;Aug&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="s1">&#39;Sep&#39;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="s1">&#39;Oct&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;Nov&#39;</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="s1">&#39;Dec&#39;</span><span class="p">:</span> <span class="mi">12</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">m</span><span class="p">:</span> <span class="nb">print</span> <span class="n">key</span><span class="p">,</span> <span class="n">m</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
<span class="gp">...</span>
<span class="go">Mar 3</span>
<span class="go">Feb 2</span>
<span class="go">Aug 8</span>
<span class="go">Sep 9</span>
<span class="go">May 5</span>
<span class="go">Jun 6</span>
<span class="go">Jul 7</span>
<span class="go">Jan 1</span>
<span class="go">Apr 4</span>
<span class="go">Nov 11</span>
<span class="go">Dec 12</span>
<span class="go">Oct 10</span>
</pre></div>
</div>
<p>这只是默认行为。如果你想迭代键、值或键/值对，可以显式调用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">iterkeys()</span></code>、<code class="xref py py-meth docutils literal notranslate"><span class="pre">itervalues()</span></code> 或 <code class="xref py py-meth docutils literal notranslate"><span class="pre">iteritems()</span></code> 方法来获取适当的迭代器。 在一个相关的小改动中，成员运算符 <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> 现在可以用于字典，因此 <code class="docutils literal notranslate"><span class="pre">key</span> <span class="pre">in</span> <span class="pre">dict</span></code> 现在等价于 <code class="docutils literal notranslate"><span class="pre">dict.has_key(key)</span></code>。</p>
<p>文件也提供了一个迭代器，它会调用 <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a> 方法，直到文件中没有更多的行。这意味着你现在可以使用类似这样的代码来读取文件的每一行：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span>
    <span class="c1"># 对每一行执行某些操作</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>请注意，你只能在迭代器中向前移动；没有办法获取前一个元素、重置迭代器或复制迭代器。一个迭代器对象可以提供这些额外的功能，但迭代器协议只要求有一个 <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-meth docutils literal notranslate"><span class="pre">next()</span></code></a> 方法。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-53"></span><a class="pep reference external" href="https://peps.python.org/pep-0234/"><strong>PEP 234</strong></a> - 迭代器</dt><dd><p>由 Ka-Ping Yee 和 GvR 撰写；由 Python Labs 小组（主要由 GvR 和 Tim Peters）实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-255-simple-generators">
<h2>PEP 255: 简单的生成器<a class="headerlink" href="#pep-255-simple-generators" title="Link to this heading">¶</a></h2>
<p>生成器是另一个新增特性，它是与迭代器的引入相互关联的。</p>
<p>你一定熟悉在Python或C语言中函数调用的工作方式。当你调用一个函数时，它会获得一个私有命名空间，在这个命名空间中创建其局部变量。当函数执行到 <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 语句时，这些局部变量会被销毁，并将结果值返回给调用者。稍后对同一个函数的调用将获得一套全新的局部变量。但，如果局部变量在函数退出时不被丢弃呢？如果你可以在函数停止的地方稍后恢复执行呢？这就是生成器所提供的功能；它们可以被视为可恢复的函数。</p>
<p>这里是一个生成器函数的最简示例:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">generate_ints</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">i</span>
</pre></div>
</div>
<p>一个新的关键字 <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 被引入用于生成器。任何包含 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 语句的函数都是生成器函数；这由Python的字节码编译器检测到，并因此对函数进行特殊编译。由于引入了一个新的关键字，生成器必须通过在模块的源代码顶部附近包含一条 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">generators</span></code> 语句来显式启用。在Python 2.3中，这条语句将变得不再必要。</p>
<p>当你调用一个生成器函数时，它不会返回单个值；相反，它返回一个支持迭代器协议的生成器对象。在执行 <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 语句时，生成器输出 <code class="docutils literal notranslate"><span class="pre">i</span></code> 的值，类似于 <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 语句。<code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 和 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code> 语句之间的重大区别在于，当到达 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 时，生成器的执行状态被挂起，并且局部变量被保留。在下一次调用生成器的 <code class="docutils literal notranslate"><span class="pre">next()</span></code> 方法时，函数将立即在 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 语句之后恢复执行。（由于复杂的原因，<code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 语句不允许在 <a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> ... <a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 语句的 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code> 块中使用；请阅读 <span class="target" id="index-54"></span><a class="pep reference external" href="https://peps.python.org/pep-0255/"><strong>PEP 255</strong></a> 以获得关于 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 和异常交互的详细解释。）</p>
<p>下面是 <code class="xref py py-func docutils literal notranslate"><span class="pre">generate_ints()</span></code> 生成器的用法示例:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span> <span class="o">=</span> <span class="n">generate_ints</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span>
<span class="go">&lt;generator object at 0x8117f90&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">2</span>, in <span class="n">generate_ints</span>
<span class="gr">StopIteration</span>
</pre></div>
</div>
<p>你可以等价地写成 <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">generate_ints(5)</span></code> 或 <code class="docutils literal notranslate"><span class="pre">a,b,c</span> <span class="pre">=</span> <span class="pre">generate_ints(3)</span></code>。</p>
<p>在生成器函数内部， <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 语句只能不带值使用，并表示值的生成过程结束；之后，生成器不能再返回任何值。在生成器函数内部，带值的 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code>，例如 <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">5</span></code>，是语法错误。生成器结果的结束也可以通过手动引发 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 异常来指示，或者只是让执行流自然地从函数底部流出。</p>
<p>你可以通过编写自己的类并将生成器的所有局部变量存储为实例变量，手动实现生成器的效果。例如，返回一个整数列表可以通过将 <code class="docutils literal notranslate"><span class="pre">self.count</span></code> 设置为0，并让 <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-meth docutils literal notranslate"><span class="pre">next()</span></code></a> 方法递增 <code class="docutils literal notranslate"><span class="pre">self.count</span></code> 并返回它。然而，对于一个中等复杂的生成器，编写一个相应的类将会更加混乱。<code class="file docutils literal notranslate"><span class="pre">Lib/test/test_generators.py</span></code> 包含了一些更有趣的例子。其中最简单的一个使用生成器递归实现了树的中序遍历：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 一个递归地按顺序生成 Tree 叶子节点的生成器。</span>
<span class="k">def</span><span class="w"> </span><span class="nf">inorder</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">t</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inorder</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">left</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">x</span>
        <span class="k">yield</span> <span class="n">t</span><span class="o">.</span><span class="n">label</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inorder</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">right</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">x</span>
</pre></div>
</div>
<p>在 <code class="file docutils literal notranslate"><span class="pre">Lib/test/test_generators.py</span></code> 中还有另外两个例子，它们分别解决了N皇后问题（在$NxN$的棋盘上放置$N$个皇后，使得没有任何皇后威胁到其他皇后）和骑士巡游问题（在$NxN$的棋盘上，骑士访问每一个方格且不重复访问任何方格的路径）。</p>
<p>生成器的概念源自其他编程语言，尤其是 Icon（<a class="reference external" href="https://www2.cs.arizona.edu/icon/">https://www2.cs.arizona.edu/icon/</a> ），在 Icon 语言中，生成器的概念是核心。在 Icon 中，每个表达式和函数调用生成器的概念源自其他编程语言，尤其是 Icon。 在 Icon 中，每个表达式和函数调用都可以表现得像一个生成器。 以下是来自“Icon 编程语言概述”中的一个示例，展示了生成器的用法 <a class="reference external" href="https://www2.cs.arizona.edu/icon/docs/ipd266.htm">https://www2.cs.arizona.edu/icon/docs/ipd266.htm</a> ：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">sentence</span> <span class="o">:=</span> <span class="s2">&quot;Store it in the neighboring harbor&quot;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">:=</span> <span class="n">find</span><span class="p">(</span><span class="s2">&quot;or&quot;</span><span class="p">,</span> <span class="n">sentence</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="n">then</span> <span class="n">write</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>在Icon中，<code class="xref py py-func docutils literal notranslate"><span class="pre">find()</span></code> 函数返回子字符串&quot;or&quot;所在的索引：3、23、33。在 <a class="reference internal" href="../reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 语句中，<code class="docutils literal notranslate"><span class="pre">i</span></code> 首先被赋值为 3，但 3 小于 5，因此比较失败，Icon 会使用第二个值 23 进行重试。 23 大于 5，因此比较成功，代码将值 23 打印到屏幕上。</p>
<p>Python 并没有像 Icon 那样将生成器作为核心概念来采纳。生成器被认为是 Python 核心语言的一部分，但学习或使用它们并不是强制性的；如果它们不能解决你的问题，可以完全忽略它们。与 Icon 相比，Python 的一个新颖特性是生成器的状态表示为一个具体对象（迭代器），该对象可以传递给其他函数或存储在数据结构中。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-55"></span><a class="pep reference external" href="https://peps.python.org/pep-0255/"><strong>PEP 255</strong></a> - 简单生成器</dt><dd><p>由 Neil Schemenauer, Tim Peters, Magnus Lie Hetland 撰写。 主要由 Neil Schemenauer 和 Tim Peters 实现，并包含来自 Python Labs 团队的修正。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-237-unifying-long-integers-and-integers">
<h2>PEP 237: 统一长整数和整数<a class="headerlink" href="#pep-237-unifying-long-integers-and-integers" title="Link to this heading">¶</a></h2>
<p>在最近的版本中，普通整数（在大多数机器上是 32 位值）和长整数（可以是任意大小）的区别变得令人烦恼。 例如，在支持大于 <code class="docutils literal notranslate"><span class="pre">2**32</span></code> 比特的文件的平台上，文件对象的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">tell()</span></code> 方法必须返回一个长整数。 然而，Python 的各个部分期望普通整数，如果提供了长整数，则会引发错误。 例如，在 Python 1.5 中，只有普通整数可以用作切片索引，而 <code class="docutils literal notranslate"><span class="pre">'abc'[1L:]</span></code> 会引发一个 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 异常，并显示消息“slice index must be int”。</p>
<p>Python 2.2 将根据需要将数值从短整数转换为长整数。'L' 后缀不再需要用于表示长整数字面量，因为现在编译器会自动选择适当的类型。（在未来的 2.x 版本的 Python 中，使用 'L' 后缀将被不鼓励，并在 Python 2.4 中触发警告，可能在 Python 3.0 中被移除。）许多以前会引发 <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a> 的操作现在会返回一个长整数作为结果。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1234567890123</span>
<span class="go">1234567890123L</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span> <span class="o">**</span> <span class="mi">64</span>
<span class="go">18446744073709551616L</span>
</pre></div>
</div>
<p>在大多数情况下，整数和长整数现在将被视为相同。你仍然可以使用内置的 <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> 函数区分它们，但这很少需要。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-56"></span><a class="pep reference external" href="https://peps.python.org/pep-0237/"><strong>PEP 237</strong></a> - 统一长整数和整数</dt><dd><p>由 Moshe Zadka 和 Guido van Rossum 撰写 ; 大部分由 Guido van Rossum 实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-238-changing-the-division-operator">
<h2>PEP 238：修改除法运算符<a class="headerlink" href="#pep-238-changing-the-division-operator" title="Link to this heading">¶</a></h2>
<p>Python 2.2中最具争议的变化预示着修复一个自Python诞生以来的旧设计缺陷的努力的开始。目前，Python的除法操作符 <code class="docutils literal notranslate"><span class="pre">/</span></code> 在接收两个整数参数时表现得像C语言的除法操作符：它返回一个被截断为整数的结果。例如，<code class="docutils literal notranslate"><span class="pre">3/2</span></code> 是1，而不是1.5，<code class="docutils literal notranslate"><span class="pre">(-1)/2</span></code> 是-1，而不是-0.5。这意味着除法的结果可能会根据两个操作数的类型而意外变化，并且由于Python是动态类型的，确定操作数的可能类型可能会很困难。</p>
<p>（争议在于这是否*真的*算是一个设计缺陷，以及是否值得为了修复它而破坏现有代码。这在python-dev上引发了无休止的讨论，并在2001年7月爆发成一场在 <em class="newsgroup">comp.lang.python</em> 的充满讽刺性言辞的风暴。我不会在这里为任何一方辩护，只会描述在2.2中实现的内容。请阅读 <span class="target" id="index-57"></span><a class="pep reference external" href="https://peps.python.org/pep-0238/"><strong>PEP 238</strong></a> 以获取争论和反驳的摘要。）</p>
<p>由于这一变化可能会破坏现有代码，因此它正在非常逐步地引入。Python 2.2 开始了这一过渡，但直到 Python 3.0 这一转换才会完全完成。</p>
<p>首先，我将借用一些来自 <span class="target" id="index-58"></span><a class="pep reference external" href="https://peps.python.org/pep-0238/"><strong>PEP 238</strong></a> 的术语。“真除法”是大多数非程序员所熟悉的除法：3/2是1.5，1/4是0.25，等等。“地板除法”是Python的 <code class="docutils literal notranslate"><span class="pre">/</span></code> 操作符在给定整数操作数时当前执行的操作；其结果是真除法返回值的地板值。“经典除法”是当前 <code class="docutils literal notranslate"><span class="pre">/</span></code> 操作符的混合行为；当操作数是整数时，它返回地板除法的结果，而当其中一个操作数是浮点数时，它返回真除法的结果。</p>
<p>Python 2.2 引入了以下变化：</p>
<ul>
<li><p>一个新的操作符，<code class="docutils literal notranslate"><span class="pre">//</span></code> 是地板除法操作符。 （是的，我们知道它看起来像 C++ 的注释符号。） <code class="docutils literal notranslate"><span class="pre">//</span></code> <em>始终</em> 执行地板除法，无论其操作数的类型是什么，因此 <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">//</span> <span class="pre">2</span></code> 是 0，<code class="docutils literal notranslate"><span class="pre">1.0</span> <span class="pre">//</span> <span class="pre">2.0</span></code> 也是0.0。</p>
<p><code class="docutils literal notranslate"><span class="pre">//</span></code> 操作符在Python 2.2中始终可用；你不需要通过 <code class="docutils literal notranslate"><span class="pre">__future__</span></code> 语句来启用它。</p>
</li>
<li><p>通过在模块中包含 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">division</span></code>，<code class="docutils literal notranslate"><span class="pre">/``操作符将被更改为返回真除法的结果，因此</span> <span class="pre">``1/2</span></code> 是0.5。如果没有这条 <code class="docutils literal notranslate"><span class="pre">__future__</span></code> 语句，<code class="docutils literal notranslate"><span class="pre">/</span></code> 仍然表示经典除法。<code class="docutils literal notranslate"><span class="pre">/</span></code> 的默认含义在Python 3.0之前不会改变。</p></li>
<li><p>类可以定义名为 <a class="reference internal" href="../reference/datamodel.html#object.__truediv__" title="object.__truediv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__truediv__()</span></code></a> 和 <a class="reference internal" href="../reference/datamodel.html#object.__floordiv__" title="object.__floordiv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__floordiv__()</span></code></a> 的方法来重载这两个除法操作符。 在 C 语言层面，<a class="reference internal" href="../c-api/typeobj.html#c.PyNumberMethods" title="PyNumberMethods"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyNumberMethods</span></code></a> 结构中也有槽位，因此扩展类型可以定义这两个操作符。</p></li>
<li><p>Python 2.2 支持一些命令行参数，用于测试代码是否能在除法语义改变的情况下正常工作。运行 Python 并使用 -Q warn 选项时，当对两个整数应用除法时会发出警告。你可以利用这个功能找到受影响的代码并进行修复。默认情况下，Python 2.2 会执行经典除法而不会发出警告；在 Python 2.3 中，警告将默认开启。</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-59"></span><a class="pep reference external" href="https://peps.python.org/pep-0238/"><strong>PEP 238</strong></a>：改变除法运算符</dt><dd><p>由 Moshe Zadka 和 Guido van Rossum 撰写 ; 由 Guido van Rossum 实现。</p>
</dd>
</dl>
</div>
</section>
<section id="unicode-changes">
<h2>Unicode 的改变<a class="headerlink" href="#unicode-changes" title="Link to this heading">¶</a></h2>
<p>Python的Unicode支持在2.2版本中有所增强。Unicode字符串通常以UCS-2形式存储，即16位无符号整数。通过向配置脚本提供 <code class="xref std std-option docutils literal notranslate"><span class="pre">--enable-unicode=ucs4</span></code> 选项，Python 2.2也可以编译为使用UCS-4（32位无符号整数）作为其内部编码。（也可以指定 <code class="xref std std-option docutils literal notranslate"><span class="pre">--disable-unicode</span></code> 选项来完全禁用Unicode支持。）</p>
<p>当构建为使用 UCS-4（称为“宽Python”）时，解释器可以原生处理从 U+000000 到 U+110000 的 Unicode 字符，因此 <code class="xref py py-func docutils literal notranslate"><span class="pre">unichr()</span></code> 函数的合法值范围也相应扩大。 使用编译为 UCS-2（称为“窄Python”）的解释器时，值大于 65535 仍将导致 <code class="xref py py-func docutils literal notranslate"><span class="pre">unichr()</span></code> 函数引发 <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 异常。 所有这些内容在 <span class="target" id="index-60"></span><a class="pep reference external" href="https://peps.python.org/pep-0261/"><strong>PEP 261</strong></a> “支持‘宽’Unicode字符”中有详细描述；请查阅以获取更多细节。</p>
<p>另一个变化的解释更为简单。 自引入以来，Unicode 字符串支持一个 <code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code> 方法，可以将字符串转换为选定的编码，如 UTF-8 或 Latin-1。 在 2.2 版本中，为 8 位字符串（但不是Unicode字符串）添加了一个对称的 <code class="docutils literal notranslate"><span class="pre">decode([*encoding*])</span></code> 方法。 <code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code> 方法假定字符串使用指定的编码，并对其进行解码，返回由编解码器返回的内容。</p>
<p>利用这一新特性，编解码器被添加用于与Unicode不直接相关的任务。例如，已经添加了用于uu编码、MIME的base64编码以及使用 <a class="reference internal" href="../library/zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a> 模块进行压缩的编解码器：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Here is a lengthy piece of redundant, overly verbose,</span>
<span class="gp">... </span><span class="s2">and repetitive text.</span>
<span class="gp">... </span><span class="s2">&quot;&quot;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;zlib&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">&#39;x\x9c\r\xc9\xc1\r\x80 \x10\x04\xc0?Ul...&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;zlib&#39;</span><span class="p">)</span>
<span class="go">&#39;Here is a lengthy piece of redundant, overly verbose,\nand repetitive text.\n&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">s</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;uu&#39;</span><span class="p">)</span>
<span class="go">begin 666 &lt;data&gt;</span>
<span class="go">M2&amp;5R92!I&lt;R!A(&amp;QE;F=T:&#39;D@&lt;&amp;EE8V4@;V8@&lt;F5D=6YD86YT+&quot;!O=F5R;&#39;D@</span>
<span class="go">&gt;=F5R8F]S92P*86YD(&#39;)E&lt;&amp;5T:71I=F4@=&amp;5X=&quot;X*</span>

<span class="go">end</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;sheesh&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;rot-13&#39;</span><span class="p">)</span>
<span class="go">&#39;furrfu&#39;</span>
</pre></div>
</div>
<p>要将类实例转换为Unicode，类可以定义一个 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__unicode__()</span></code> 方法，类似于 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code> 方法。</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code>、<code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__unicode__()</span></code> 方法由 Marc-André Lemburg 实现。 支持内部使用 UCS-4 的更改由 Fredrik Lundh 和 Martin von Löwis 实现。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-61"></span><a class="pep reference external" href="https://peps.python.org/pep-0261/"><strong>PEP 261</strong></a> - 对 '宽' Unicode 字符的支持</dt><dd><p>由 Paul Prescod 编写。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-227-nested-scopes">
<h2>PEP 227: 嵌套的作用域<a class="headerlink" href="#pep-227-nested-scopes" title="Link to this heading">¶</a></h2>
<p>在Python 2.1中，静态嵌套作用域作为一个可选特性被添加，需要通过 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">nested_scopes</span></code> 指令来启用。在2.2版本中，嵌套作用域不再需要特别启用，现在总是存在。本节的其余部分是从我的《Python 2.1的新特性》文档中复制的嵌套作用域描述；如果你在2.1发布时已经阅读过，可以跳过本节的其余部分。</p>
<p>Python 2.1 中的最大改变是 Python 的作用域规则，在Python 2.2中得到完善。 在 Python 2.0 中，任意给定的时刻至多使用三个命名空间来查找变量名称：局部、模块和内置命名空间。 这往往会导致令人吃惊的结果因为它与人们直觉上的预期不相匹配。 例如，一个嵌套的递归函数将不起作用:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">():</span>
    <span class="o">...</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">g</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="n">g</span><span class="p">(</span><span class="n">value</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>函数 <code class="xref py py-func docutils literal notranslate"><span class="pre">g()</span></code> 将始终引发 <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> 异常，因为名称 <code class="docutils literal notranslate"><span class="pre">g</span></code> 的绑定既不在其局部命名空间中，也不在模块级命名空间中。这在实际中并不是什么大问题（你有多常递归地定义这样的内部函数？），但这也使得使用 <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> 表达式变得笨拙，这在实践中确实是个问题。在使用 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code> 的代码中，你经常可以看到局部变量通过将它们作为参数的默认值传递来进行复制。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="s2">&quot;Return list of any entries equal to &#39;name&#39;&quot;</span>
    <span class="n">L</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="n">name</span><span class="p">,</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">list_attribute</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">L</span>
</pre></div>
</div>
<p>结果将会严重损害以高度函数式风格编写的 Python 代码的可读性。</p>
<p>Python 2.2 最显著的改变是增加了静态作用域这一语言特征来解决此问题。 作为它的第一项影响，在上述示例中的 <code class="docutils literal notranslate"><span class="pre">name=name</span></code> 默认参数现在将不再必要。 简单地说，当一个函数内部的给定变量名没有被赋值时（通过赋值语句，或者 <a class="reference internal" href="../reference/compound_stmts.html#def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">def</span></code></a>, <a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">class</span></code></a> 或 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句），对该变量的引用将在外层作用域的局部命名空间中查找。 对于该规则的更详细解释，以及具体实现的分析，请参阅相应的 PEP。</p>
<p>对于同时在模块层级和包含下层函数定义的函数内部局部变量使用了相同变量名的代码来说这项改变可能会导致一些兼容性问题。 不过这看来不太可能发生，因为阅读这样的代码本来就会相当令人困惑。</p>
<p>此项改变的一个附带影响是在特定条件下函数作用域内部 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> 和 <code class="docutils literal notranslate"><span class="pre">exec</span></code> 语句将不允许使用。 Python 参考手册已经写明 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> 仅在模块最高层级上是可用的，但此前 CPython 解释器从未强制实施此规则。 作为嵌套作用域具体实现的一部分，将 Python 源码转为字节码的编译器会生成不同的代码来访问某个包含作用域内的变量。 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> 和 <code class="docutils literal notranslate"><span class="pre">exec</span></code> 会使得编译器无法正确执行，因为它们会向局部命名空间添加在编译时还不存在的名称。 为此，如果一个函数包含带有自由变量的函数定义或 <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> 表达式，编译器将通过引发 <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> 异常来提示。</p>
<p>为了使前面的解释更清楚，下面是一个例子:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">():</span>
    <span class="c1"># 下一行有语法错误</span>
    <span class="n">exec</span> <span class="s1">&#39;x=2&#39;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">g</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">x</span>
</pre></div>
</div>
<p>包含 <code class="docutils literal notranslate"><span class="pre">exec</span></code> 语句的第 4 行有语法错误，因为 <code class="docutils literal notranslate"><span class="pre">exec</span></code> 会定义一个名为 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的新局部变量，它的值应当被 <code class="xref py py-func docutils literal notranslate"><span class="pre">g()</span></code> 所访问。</p>
<p>这应该不会是太大的限制，因为 <code class="docutils literal notranslate"><span class="pre">exec</span></code> 在多数 Python 代码中都极少被使用（而当它被使用时，往往也是个存在糟糕设计的信号）。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-62"></span><a class="pep reference external" href="https://peps.python.org/pep-0227/"><strong>PEP 227</strong></a> - 静态嵌套作用域</dt><dd><p>由 Jeremy Hylton 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="new-and-improved-modules">
<h2>新增和改进的模块<a class="headerlink" href="#new-and-improved-modules" title="Link to this heading">¶</a></h2>
<ul>
<li><p><a class="reference internal" href="../library/xmlrpc.client.html#module-xmlrpc.client" title="xmlrpc.client: XML-RPC client access."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpclib</span></code></a> 模块由 Fredrik Lundh 贡献给标准库，提供了编写 XML-RPC 客户端的支持。 XML-RPC 是一种建立在 HTTP 和 XML 之上的简单远程过程调用协议。 例如，以下代码片段从 O'Reilly Network 检索 RSS 频道列表，然后列出一个频道的最新头条新闻：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">xmlrpclib</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">xmlrpclib</span><span class="o">.</span><span class="n">Server</span><span class="p">(</span>
      <span class="s1">&#39;http://www.oreillynet.com/meerkat/xml-rpc/server.php&#39;</span><span class="p">)</span>
<span class="n">channels</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">meerkat</span><span class="o">.</span><span class="n">getChannels</span><span class="p">()</span>
<span class="c1"># channels 是由字典组成的列表，就像这样：</span>
<span class="c1"># [{&#39;id&#39;: 4, &#39;title&#39;: &#39;Freshmeat Daily News&#39;}</span>
<span class="c1">#  {&#39;id&#39;: 190, &#39;title&#39;: &#39;32Bits Online&#39;},</span>
<span class="c1">#  {&#39;id&#39;: 4549, &#39;title&#39;: &#39;3DGamers&#39;}, ... ]</span>

<span class="c1"># 从获取一个 channel 的条目</span>
<span class="n">items</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">meerkat</span><span class="o">.</span><span class="n">getItems</span><span class="p">(</span> <span class="p">{</span><span class="s1">&#39;channel&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span> <span class="p">)</span>

<span class="c1"># &#39;items&#39; 是另一个由字典组成的列表，就像这样：</span>
<span class="c1"># [{&#39;link&#39;: &#39;http://freshmeat.net/releases/52719/&#39;,</span>
<span class="c1">#   &#39;description&#39;: &#39;A utility which converts HTML to XSL FO.&#39;,</span>
<span class="c1">#   &#39;title&#39;: &#39;html2fo 0.3 (Default)&#39;}, ... ]</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/xmlrpc.server.html#module-xmlrpc.server" title="xmlrpc.server: Basic XML-RPC server implementations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">SimpleXMLRPCServer</span></code></a> 模块使创建简单的 XML-RPC 服务器变得容易。 有关 XML-RPC 的更多信息，请参见 <a class="reference external" href="http://xmlrpc.scripting.com/">http://xmlrpc.scripting.com/</a>。</p>
</li>
<li><p>新的 <a class="reference internal" href="../library/hmac.html#module-hmac" title="hmac: Keyed-Hashing for Message Authentication (HMAC) implementation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">hmac</span></code></a> 模块实现了由 <span class="target" id="index-63"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2104.html"><strong>RFC 2104</strong></a> 描述的HMAC算法。（由Gerhard Häring贡献。）</p></li>
<li><p>几个最初返回长元组的函数现在返回伪序列，这些伪序列仍然像元组一样工作，但也具有助记属性，例如 <code class="xref py py-attr docutils literal notranslate"><span class="pre">memberst_mtime</span></code> 或 <a class="reference internal" href="../library/time.html#time.struct_time.tm_year" title="time.struct_time.tm_year"><code class="xref py py-attr docutils literal notranslate"><span class="pre">tm_year</span></code></a>。增强的函数包括 <a class="reference internal" href="../library/os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os</span></code></a> 模块中的 <a class="reference internal" href="../library/os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal notranslate"><span class="pre">stat()</span></code></a>、<a class="reference internal" href="../library/os.html#os.fstat" title="os.fstat"><code class="xref py py-func docutils literal notranslate"><span class="pre">fstat()</span></code></a>、<a class="reference internal" href="../library/os.html#os.statvfs" title="os.statvfs"><code class="xref py py-func docutils literal notranslate"><span class="pre">statvfs()</span></code></a> 和 <a class="reference internal" href="../library/os.html#os.fstatvfs" title="os.fstatvfs"><code class="xref py py-func docutils literal notranslate"><span class="pre">fstatvfs()</span></code></a>，以及 <a class="reference internal" href="../library/time.html#module-time" title="time: Time access and conversions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">time</span></code></a> 模块中的 <a class="reference internal" href="../library/time.html#time.localtime" title="time.localtime"><code class="xref py py-func docutils literal notranslate"><span class="pre">localtime()</span></code></a>、<a class="reference internal" href="../library/time.html#time.gmtime" title="time.gmtime"><code class="xref py py-func docutils literal notranslate"><span class="pre">gmtime()</span></code></a> 和 <a class="reference internal" href="../library/time.html#time.strptime" title="time.strptime"><code class="xref py py-func docutils literal notranslate"><span class="pre">strptime()</span></code></a>。</p>
<p>例如，使用旧的元组来获取文件的大小时，你可能会写成 <code class="docutils literal notranslate"><span class="pre">file_size</span> <span class="pre">=</span> <span class="pre">os.stat(filename)[stat.ST_SIZE]</span></code> ，但现在可以更清晰地写成 <code class="docutils literal notranslate"><span class="pre">file_size</span> <span class="pre">=</span> <span class="pre">os.stat(filename).st_size</span></code>。</p>
<p>此特性的初始补丁由 Nick Mathewson 贡献。</p>
</li>
<li><p>Python 的分析器进行了大量的重构，并纠正了其输出中的各种错误。（由 Fred L. Drake, Jr. 和 Tim Peters 贡献。）</p></li>
<li><p><a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> 模块可以编译为支持IPv6；为Python的配置脚本指定 <code class="xref std std-option docutils literal notranslate"><span class="pre">--enable-ipv6</span></code> 选项。（由Jun-ichiro &quot;itojun&quot; Hagino贡献。）</p></li>
<li><p>在支持 C 语言 long long 类型的平台上，为 64 位整数添加了两个新的格式字符到 <a class="reference internal" href="../library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> 模块。 <code class="docutils literal notranslate"><span class="pre">q</span></code> 用于有符号 64 位整数，<code class="docutils literal notranslate"><span class="pre">Q</span></code> 用于无符号 64 位整数。返回的值是 Python 的长整数类型。（由 Tim Peters 贡献。）</p></li>
<li><p>在解释器的交互模式下，有一个新的内置函数 <a class="reference internal" href="../library/functions.html#help" title="help"><code class="xref py py-func docutils literal notranslate"><span class="pre">help()</span></code></a>，它使用在Python 2.1 中引入的 <a class="reference internal" href="../library/pydoc.html#module-pydoc" title="pydoc: Documentation generator and online help system."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code></a> 模块来提供交互式帮助。 <code class="docutils literal notranslate"><span class="pre">help(object)</span></code> 显示关于*object*的任何可用帮助文本。不带参数调用 <a class="reference internal" href="../library/functions.html#help" title="help"><code class="xref py py-func docutils literal notranslate"><span class="pre">help()</span></code></a> 会进入一个在线帮助工具，在那里你可以输入函数、类或模块的名称来阅读它们的帮助文本。（由Guido van Rossum贡献，使用Ka-Ping Yee的 <a class="reference internal" href="../library/pydoc.html#module-pydoc" title="pydoc: Documentation generator and online help system."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code></a> 模块。）</p></li>
<li><p>对 <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 模块底层的 SRE 引擎进行了各种错误修复和性能改进。例如，<a class="reference internal" href="../library/re.html#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.sub()</span></code></a> 和 <a class="reference internal" href="../library/re.html#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.split()</span></code></a> 函数已用 C 语言重写。 另一个贡献的补丁将某些 Unicode 字符范围的速度提高了两倍，并新增了一个 <a class="reference internal" href="../library/re.html#re.finditer" title="re.finditer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">finditer()</span></code></a> 方法，该方法返回给定字符串中所有不重叠匹配的迭代器。（SRE 由 Fredrik Lundh 维护。 BIGCHARSET 补丁由 Martin von Löwis 贡献。）</p></li>
<li><p><a class="reference internal" href="../library/smtplib.html#module-smtplib" title="smtplib: SMTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">smtplib</span></code></a> 模块现在支持 <span class="target" id="index-64"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2487.html"><strong>RFC 2487</strong></a>：&quot;Secure SMTP over TLS&quot;，因此现在可以加密Python程序与接收消息的邮件传输代理之间的SMTP流量。<a class="reference internal" href="../library/smtplib.html#module-smtplib" title="smtplib: SMTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">smtplib</span></code></a> 还支持SMTP身份验证。（由Gerhard Häring贡献。）</p></li>
<li><p><a class="reference internal" href="../library/imaplib.html#module-imaplib" title="imaplib: IMAP4 protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">imaplib</span></code></a> 模块由 Piers Lauder 维护，支持几个新扩展: <span class="target" id="index-65"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2342.html"><strong>RFC 2342</strong></a> 中定义的 NAMESPACE 扩展、SORT、GETACL和SETACL。（由 Anthony Baxter 和 Michel Pelletier 贡献。）</p></li>
<li><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">rfc822</span></code> 模块对电子邮件地址的解析现在符合 <span class="target" id="index-66"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2822.html"><strong>RFC 2822</strong></a>，这是对 <span class="target" id="index-67"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc822.html"><strong>RFC 822</strong></a> 的更新。（模块名称 <em>不会</em> 更改为 <code class="docutils literal notranslate"><span class="pre">rfc2822</span></code>。） 新增了一个包 <a class="reference internal" href="../library/email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code></a>，用于解析和生成电子邮件消息。（由 Barry Warsaw 贡献，并源于他在 Mailman 上的工作。）</p></li>
<li><p><a class="reference internal" href="../library/difflib.html#module-difflib" title="difflib: Helpers for computing differences between objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">difflib</span></code></a> 模块现在包含一个新的 <code class="xref py py-class docutils literal notranslate"><span class="pre">Differ</span></code> 类，用于生成两个文本行序列之间的可读性高的变更列表（“delta”）。 还有两个生成器函数，<code class="xref py py-func docutils literal notranslate"><span class="pre">ndiff()</span></code> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">restore()</span></code>，分别从两个序列返回一个 delta，或从一个 delta 返回其中一个原始序列。 （基础工作由 David Goodger 贡献，基于 Tim Peters 的 ndiff.py 代码，后者进行了生成器化。）</p></li>
<li><p>为 <a class="reference internal" href="../library/string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code></a> 模块增加了新的常量 <code class="xref py py-const docutils literal notranslate"><span class="pre">ascii_letters</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">ascii_lowercase</span></code> 和 <code class="xref py py-const docutils literal notranslate"><span class="pre">ascii_uppercase</span></code>。 标准库中有一些模块使用 <code class="xref py py-const docutils literal notranslate"><span class="pre">string.letters</span></code> 来表示 A-Za-z，但当使用不同语言区域时其含义并不正确，因为 <code class="xref py py-const docutils literal notranslate"><span class="pre">string.letters</span></code> 会根据当前语言区域所定义的合法字符集而发生变化。 这些有问题的模块已全部被修正为改用 <code class="xref py py-const docutils literal notranslate"><span class="pre">ascii_letters</span></code>。 （由未知人士报告；由 Fred L. Drake, Jr. 修正）。</p></li>
<li><p>现在 <a class="reference internal" href="../library/mimetypes.html#module-mimetypes" title="mimetypes: Mapping of filename extensions to MIME types."><code class="xref py py-mod docutils literal notranslate"><span class="pre">mimetypes</span></code></a> 模块通过添加 <a class="reference internal" href="../library/mimetypes.html#mimetypes.MimeTypes" title="mimetypes.MimeTypes"><code class="xref py py-class docutils literal notranslate"><span class="pre">MimeTypes</span></code></a> 类让使用不同的 MIME 类型数据库更为容易，该类接受一个文件名列表供解析。 （由 Fred L. Drake, Jr. 贡献。）</p></li>
<li><p><a class="reference internal" href="../library/threading.html#threading.Timer" title="threading.Timer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Timer</span></code></a> 模块中新增了一个 <a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> 类，可以调度某个活动在未来某个时间发生。 （由 Itamar Shtull-Trauring 贡献。）</p></li>
</ul>
</section>
<section id="interpreter-changes-and-fixes">
<h2>解释器的改变和修正<a class="headerlink" href="#interpreter-changes-and-fixes" title="Link to this heading">¶</a></h2>
<p>有些变化只会影响那些在 C 级别处理 Python 解释器的人，因为他们正在编写 Python 扩展模块、嵌入解释器或仅仅是在修改解释器本身。如果你只编写 Python 代码，这里描述的变化对你几乎没有影响。</p>
<ul>
<li><p>性能分析和追踪函数现在可以用 C 语言来实现，相比基于 Python 的函数能够显著提高运行速度并能够减少性能分析和追踪的资源开销。 Python 开发环境的编写者对此将会很感兴趣。 Python 的 API 增加了两个新的 C 函数，<a class="reference internal" href="../c-api/init.html#c.PyEval_SetProfile" title="PyEval_SetProfile"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetProfile()</span></code></a> 和 <a class="reference internal" href="../c-api/init.html#c.PyEval_SetTrace" title="PyEval_SetTrace"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetTrace()</span></code></a>。 现有的 <a class="reference internal" href="../library/sys.html#sys.setprofile" title="sys.setprofile"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.setprofile()</span></code></a> 和 <a class="reference internal" href="../library/sys.html#sys.settrace" title="sys.settrace"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.settrace()</span></code></a> 函数仍然存在，并已简单地更改为使用新的 C 层级接口。 （由 Fred L. Drake, Jr. 贡献。）</p></li>
<li><p>增加了另一套低层级 API，它主要面向 Python 调试器和开发工具的实现者。 <a class="reference internal" href="../c-api/init.html#c.PyInterpreterState_Head" title="PyInterpreterState_Head"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_Head()</span></code></a> 和 <a class="reference internal" href="../c-api/init.html#c.PyInterpreterState_Next" title="PyInterpreterState_Next"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_Next()</span></code></a> 可让调用方访问所有现存的解释器对象；<a class="reference internal" href="../c-api/init.html#c.PyInterpreterState_ThreadHead" title="PyInterpreterState_ThreadHead"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_ThreadHead()</span></code></a> 和 <a class="reference internal" href="../c-api/init.html#c.PyThreadState_Next" title="PyThreadState_Next"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Next()</span></code></a> 允许对某个解释器的所有线程状态执行循环。 （由 David Beazley 贡献。）</p></li>
<li><p>垃圾收集器的 C 级接口已经发生了变化，使得编写支持垃圾收集的扩展类型和调试函数误用变得更容易。各种函数的语义略有不同，因此需要重命名一系列函数。使用旧 API 的扩展仍然可以编译，但不会参与垃圾收集，因此应优先考虑将它们更新为 2.2 版本。</p>
<p>要将一个扩展模块升级至新 API，请执行下列步骤:</p>
</li>
<li><p>将 <code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_GC</span></code> 重命名为 <a class="reference internal" href="../c-api/typeobj.html#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a>。</p></li>
<li><dl class="simple">
<dt>使用 <a class="reference internal" href="../c-api/gcsupport.html#c.PyObject_GC_New" title="PyObject_GC_New"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_New()</span></code></a> 或 <a class="reference internal" href="../c-api/gcsupport.html#c.PyObject_GC_NewVar" title="PyObject_GC_NewVar"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_NewVar()</span></code></a> 来分配</dt><dd><p>对象，并使用 <a class="reference internal" href="../c-api/gcsupport.html#c.PyObject_GC_Del" title="PyObject_GC_Del"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_Del()</span></code></a> 来释放它们。</p>
</dd>
</dl>
</li>
<li><p>将 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_Init()</span></code> 重命名为 <a class="reference internal" href="../c-api/gcsupport.html#c.PyObject_GC_Track" title="PyObject_GC_Track"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_Track()</span></code></a> 并将 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_Fini()</span></code> 重命名为 <a class="reference internal" href="../c-api/gcsupport.html#c.PyObject_GC_UnTrack" title="PyObject_GC_UnTrack"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_UnTrack()</span></code></a>。</p></li>
<li><p>从对象大小计算中移除 <code class="xref c c-macro docutils literal notranslate"><span class="pre">PyGC_HEAD_SIZE</span></code>。</p></li>
<li><p>移除对 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_AS_GC()</span></code> 和 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_FROM_GC()</span></code> 的调用。</p></li>
<li><p>向 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> 添加了一个新的 <code class="docutils literal notranslate"><span class="pre">et</span></code> 格式序列；<code class="docutils literal notranslate"><span class="pre">et</span></code> 接受一个形参和一个编码格式名称，如果该形参值是一个 Unicode 字符串则将其转换为给定的编码格式，或者如果它是一个 8 比特位字符串则让其保持原样，即假定它已经使用了适当的编码格式。 这不同于 <code class="docutils literal notranslate"><span class="pre">es</span></code> 格式字符，它假定该 8 比特位字符串是使用 Python 默认的 ASCII 编码格式并将其转换为指定的新编码格式。 （由 M.-A. Lemburg 贡献，用于下一节所描述的 Windows 上的 MBCS 支持。）</p></li>
<li><p>增加了一个不同的解析函数 <a class="reference internal" href="../c-api/arg.html#c.PyArg_UnpackTuple" title="PyArg_UnpackTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_UnpackTuple()</span></code></a>，它更为简单并且应该也更为快速。 调用方不必再指定格式字符串，而是简单地给出所预期参数的最小和最大数量，以及一组指向将以这些参数值来填充的 <span class="c-expr sig sig-inline c"><a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span> 变量的指针。</p></li>
<li><p>在方法定义表中可使用两个新的旗标 <a class="reference internal" href="../c-api/structures.html#c.METH_NOARGS" title="METH_NOARGS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">METH_NOARGS</span></code></a> 和 <a class="reference internal" href="../c-api/structures.html#c.METH_O" title="METH_O"><code class="xref c c-macro docutils literal notranslate"><span class="pre">METH_O</span></code></a> 来简化无参数或只有单个未定类型参数的方法的实现。 调用这样的方法比调用使用 <a class="reference internal" href="../c-api/structures.html#c.METH_VARARGS" title="METH_VARARGS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">METH_VARARGS</span></code></a> 的相应方法更高效。 此外，编写 C 方法的旧风格 <code class="xref c c-macro docutils literal notranslate"><span class="pre">METH_OLDARGS</span></code> 现已正式被弃用。</p></li>
<li><p>新增了两个包装器函数 <a class="reference internal" href="../c-api/conversion.html#c.PyOS_snprintf" title="PyOS_snprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyOS_snprintf()</span></code></a> 和 <a class="reference internal" href="../c-api/conversion.html#c.PyOS_vsnprintf" title="PyOS_vsnprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyOS_vsnprintf()</span></code></a> 以提供相对较新的 <code class="xref c c-func docutils literal notranslate"><span class="pre">snprintf()</span></code> 和 <code class="xref c c-func docutils literal notranslate"><span class="pre">vsnprintf()</span></code> C 库 API 的跨平台实现。 与标准的 <code class="xref c c-func docutils literal notranslate"><span class="pre">sprintf()</span></code> 和 <code class="xref c c-func docutils literal notranslate"><span class="pre">vsprintf()</span></code> 函数相比，Python 版本会检查缓冲区边界用以防止缓冲区溢出。 （由 M.-A. Lemburg 贡献。）</p></li>
<li><p><a class="reference internal" href="../c-api/tuple.html#c._PyTuple_Resize" title="_PyTuple_Resize"><code class="xref c c-func docutils literal notranslate"><span class="pre">_PyTuple_Resize()</span></code></a> 函数去掉了一个未使用的形参，因此现在它接受 2 个形参而不是 3 个。 第三个参数从未被使用，在将代码从较早的版本移植到 Python 2.2 时可以简单地丢弃它。</p></li>
</ul>
</section>
<section id="other-changes-and-fixes">
<h2>其他的改变和修正<a class="headerlink" href="#other-changes-and-fixes" title="Link to this heading">¶</a></h2>
<p>像往常一样，源代码树中散布着许多其他改进和错误修复。通过搜索 CVS 更改日志，可以发现 Python 2.1 到 2.2 之间应用了 527 个补丁并修复了 683 个错误；2.2.1 应用了 139 个补丁并修复了 143 个错误；2.2.2 应用了 106 个补丁并修复了 82 个错误。这些数字可能是低估的。</p>
<p>一些较为重要的改变:</p>
<ul>
<li><p>适用于 MacOS 的 Python 移植代码现在保存在主 Python CVS 树中，由 Jack Jansen 维护，并且为了支持 MacOS X，进行了许多更改。</p>
<p>最重要的变化是能够将 Python 作为框架来进行构建，这可以通过在编译 Python 时向配置脚本提供 <code class="xref std std-option docutils literal notranslate"><span class="pre">--enable-framework</span></code> 选项来启用。 根据 Jack Jansen 的说法，“这会将一个独立的 Python 安装版加上 OS X 框架‘粘合起来’放到 <code class="file docutils literal notranslate"><span class="pre">/Library/Frameworks/Python.framework</span></code> 中（或者其他选定的位置）。 就目前而言这样做并没有什么直接的额外好处（实际上，这样做还存在必须更改 PATH 才能找到Python 的坏处），但它是创建完整的 Python 应用程序、移植 MacPython IDE、并可能使用 Python 作为标准 OSA 脚本语言及其他更多功能的基础。”</p>
<p>作为 MacOS API 如 windowing, QuickTime, scripting 等的接口的许多 MacPython 工具箱模块已被移植到 OS X，但它们在 <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> 中被注释掉了。 希望尝试这些模块的人可以手动取消注释它们。</p>
</li>
<li><p>现在将关键字参数传给不接受它们的内置函数会导致引发 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 异常，并附带消息 &quot;<em>function</em> takes no keyword arguments&quot;。</p></li>
<li><p>在 Python 2.1 中作为扩展模块加入的弱引用现在已成为核心组成部分，因为它们被用于新式类的实现。 为此 <a class="reference internal" href="../library/exceptions.html#ReferenceError" title="ReferenceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ReferenceError</span></code></a> 异常也已从 <a class="reference internal" href="../library/weakref.html#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal notranslate"><span class="pre">weakref</span></code></a> 模块移出成为一个内置异常。</p></li>
<li><p>由 Tim Peters 编写的新脚本 <code class="file docutils literal notranslate"><span class="pre">Tools/scripts/cleanfuture.py</span></code> 可自动从 Python 源代码移除过时的 <code class="docutils literal notranslate"><span class="pre">__future__</span></code> 语句。</p></li>
<li><p>向内置函数 <a class="reference internal" href="../library/functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 添加了一个额外的 <em>flags</em> 参数，以便现在 <code class="docutils literal notranslate"><span class="pre">__future__</span></code> 语句的行为能在模拟的 shell，例如由 IDLE 和其他开发环境所提供的此类工具中被正确地观察。 此特性的描述参见 <span class="target" id="index-68"></span><a class="pep reference external" href="https://peps.python.org/pep-0264/"><strong>PEP 264</strong></a>。 （由 Michael Hudson 贡献。）</p></li>
<li><p>Python 1.6 引入的新许可证与 GPL 不兼容。通过对 2.2 许可证进行一些小的文本修改，这个问题得以解决，因此现在可以合法地将 Python 嵌入到 GPL 授权的程序中。请注意，Python 本身并不是在 GPL 授权下，而是采用一个与 BSD 许可证本质上等效的许可证，这与之前的情况一样。这些许可证更改也应用到了 Python 2.0.1 和 2.1.1 版本中。</p></li>
<li><p>在 Windows 上，当 Python 遇到一个 Unicode 文件名时，现在会将其转换为 MBCS 编码的字符串，这种编码由 Microsoft 文件 API 使用。由于文件 API 明确使用 MBCS 编码，Python 默认选择 ASCII 作为编码方式显得很不方便。在 Unix 上，如果 <code class="docutils literal notranslate"><span class="pre">locale.nl_langinfo(CODESET)</span></code> 可用，Python 将使用本地字符集。（Windows 支持由 Mark Hammond 提供，Marc-André Lemburg 提供协助。Unix 支持由 Martin von Löwis 添加。）</p></li>
<li><p>大文件支持目前已在 Windows 上启用。 （由 Tim Peters 贡献。）</p></li>
<li><p><code class="file docutils literal notranslate"><span class="pre">Tools/scripts/ftpmirror.py</span></code> 脚本现在会解析 <code class="file docutils literal notranslate"><span class="pre">.netrc</span></code> 文件，如果存在的话。 （由 Mike Romberg 贡献。）</p></li>
<li><p>由 <code class="xref py py-func docutils literal notranslate"><span class="pre">xrange()</span></code> 函数所返回的对象的某些特性现在已被弃用，当它们被访问时将会触发警告；它们将在 Python 2.3 中被去除。 <code class="xref py py-class docutils literal notranslate"><span class="pre">xrange</span></code> 对象曾试图伪装成完全的序列类型，支持切片、序列乘法以及 <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> 运算符等，但这些特性很少被使用因而存在许多缺陷。 <code class="xref py py-meth docutils literal notranslate"><span class="pre">tolist()</span></code> 方法以及 <code class="xref py py-attr docutils literal notranslate"><span class="pre">start</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">stop</span></code> 和 <code class="xref py py-attr docutils literal notranslate"><span class="pre">step</span></code> 属性也已被弃用。 在 C 层级上，传给 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyRange_New()</span></code> 函数的第四个参数 <code class="docutils literal notranslate"><span class="pre">repeat</span></code> 也已被弃用。</p></li>
<li><p>字典实现中有一堆补丁，主要是为了修复潜在的核心转储问题，这些问题发生在字典中包含的对象悄悄改变其哈希值，或者在它们所包含的字典中发生突变时。那段时间，python-dev 邮件列表进入了一个微妙的节奏：Michael Hudson 发现一个导致核心转储的案例，Tim Peters 修复这个 bug，接着 Michael 又发现另一个案例，如此反复循环。</p></li>
<li><p>在 Windows 上，Python 现在可以使用 Borland C 编译，这要归功于 Stephen Hansen 提供的多个补丁，尽管结果还不完全可用。（但这*确实*是一个进步……）</p></li>
<li><p>另一个 Windows 改进：Wise Solutions 慷慨地向 PythonLabs 提供了他们的 InstallerMaster 8.1 系统。早期的 PythonLabs Windows 安装程序使用的是 Wise 5.0a，已经开始显得过时。（由 Tim Peters 打包。）</p></li>
<li><p>在 Windows 上现在将会导入以 <code class="docutils literal notranslate"><span class="pre">.pyw</span></code> 结尾的文件。 <code class="docutils literal notranslate"><span class="pre">.pyw</span></code> 是 Windows 专属的，用来指明一个脚本需要使用 PYTHONW.EXE 而不是 PYTHON.EXE 来运行以避免弹出 DOS 控制台来显示输出。 该补丁使得导入这样的脚本成为可能，让它们也可以作为模块来使用。 （由 David Bolen 实现。）</p></li>
<li><p>在 Python 会使用 C <code class="xref c c-func docutils literal notranslate"><span class="pre">dlopen()</span></code> 函数来加载扩展模块的平台上，现在可以使用 <a class="reference internal" href="../library/sys.html#sys.getdlopenflags" title="sys.getdlopenflags"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getdlopenflags()</span></code></a> 和 <a class="reference internal" href="../library/sys.html#sys.setdlopenflags" title="sys.setdlopenflags"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.setdlopenflags()</span></code></a> 等函数来设置 <code class="xref c c-func docutils literal notranslate"><span class="pre">dlopen()</span></code> 所使用的旗标。 （由 Bram Stolk 贡献。）</p></li>
<li><p>当传入浮点数时 <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a> 内置函数已不再支持 3 个参数。 <code class="docutils literal notranslate"><span class="pre">pow(x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code> 将返回 <code class="docutils literal notranslate"><span class="pre">(x**y)</span> <span class="pre">%</span> <span class="pre">z</span></code>，但这对于浮点数来说没有用处，并且其最终结果会因具体平台的不同而产生不可预料的变化。 现在 <code class="docutils literal notranslate"><span class="pre">pow(2.0,</span> <span class="pre">8.0,</span> <span class="pre">7.0)</span></code> 这样的调用将会引发 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 异常。</p></li>
</ul>
</section>
<section id="acknowledgements">
<h2>致谢<a class="headerlink" href="#acknowledgements" title="Link to this heading">¶</a></h2>
<p>作者感谢以下人员为本文的各种草案提供建议，更正和帮助： Fred Bremmer, Keith Briggs, Andrew Dalke, Fred L. Drake, Jr., Carel Fellinger, David Goodger, Mark Hammond, Stephen Hansen, Michael Hudson, Jack Jansen, Marc-André Lemburg, Martin von Löwis, Fredrik Lundh, Michael McLay, Nick Mathewson, Paul Moore, Gustavo Niemeyer, Don O'Donnell, Joonas Paalasma, Tim Peters, Jens Quade, Tom Reinhardt, Neil Schemenauer, Guido van Rossum, Greg Ward, Edward Welbourne.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#">Python 2.2 有什么新变化</a><ul>
<li><a class="reference internal" href="#introduction">概述</a></li>
<li><a class="reference internal" href="#peps-252-and-253-type-and-class-changes">PEP 252 和 253：类型和类的修改</a><ul>
<li><a class="reference internal" href="#old-and-new-classes">旧式类和新式类</a></li>
<li><a class="reference internal" href="#descriptors">描述器</a></li>
<li><a class="reference internal" href="#multiple-inheritance-the-diamond-rule">多重继承：钻石规则</a></li>
<li><a class="reference internal" href="#attribute-access">属性访问</a></li>
<li><a class="reference internal" href="#related-links">相关链接</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pep-234-iterators">PEP 234: 迭代器</a></li>
<li><a class="reference internal" href="#pep-255-simple-generators">PEP 255: 简单的生成器</a></li>
<li><a class="reference internal" href="#pep-237-unifying-long-integers-and-integers">PEP 237: 统一长整数和整数</a></li>
<li><a class="reference internal" href="#pep-238-changing-the-division-operator">PEP 238：修改除法运算符</a></li>
<li><a class="reference internal" href="#unicode-changes">Unicode 的改变</a></li>
<li><a class="reference internal" href="#pep-227-nested-scopes">PEP 227: 嵌套的作用域</a></li>
<li><a class="reference internal" href="#new-and-improved-modules">新增和改进的模块</a></li>
<li><a class="reference internal" href="#interpreter-changes-and-fixes">解释器的改变和修正</a></li>
<li><a class="reference internal" href="#other-changes-and-fixes">其他的改变和修正</a></li>
<li><a class="reference internal" href="#acknowledgements">致谢</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一主题</h4>
    <p class="topless"><a href="2.3.html"
                          title="上一章">Python 2.3 有什么新变化</a></p>
  </div>
  <div>
    <h4>下一主题</h4>
    <p class="topless"><a href="2.1.html"
                          title="下一章">Python 2.1 有什么新变化</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/whatsnew/2.2.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="折叠边栏">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="2.1.html" title="Python 2.1 有什么新变化"
             >下一页</a> |</li>
        <li class="right" >
          <a href="2.3.html" title="Python 2.3 有什么新变化"
             >上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.14.0a4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python的新变化</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Python 2.2 有什么新变化</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q" id="search-box" />
          <input type="submit" value="提交" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="../copyright.html">
    
    版权所有
    
      </a>
     2001 Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
      See <a href="/license.html">History and License</a> for more information.<br />
    
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />
      最后更新于 2月 03, 2025 (05:36 UTC).
    
      <a href="/bugs.html">Found a bug</a>?
    
    <br />

    由 <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3创建。
    </div>

  </body>
</html>