<!DOCTYPE html>

<html lang="zh-CN" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="Python 2.3 有什么新变化" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/whatsnew/2.3.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="作者, A.M. Kuchling,. 本文介绍了 Python 2.3 的新特性。 Python 2.3 发布于 2003 年 7 月 29 日。 Python 2.3 的主要主题是完善在 2.2 中添加的一些功能、为核心语言添加各种小但实用的增强功能，以及扩展标准库。 上一版本引入的新对象模型已经受益于 18 个月的错误修复和优化努力，这些优化提升了新式类的性能。 新增了几个内置函数，例..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="作者, A.M. Kuchling,. 本文介绍了 Python 2.3 的新特性。 Python 2.3 发布于 2003 年 7 月 29 日。 Python 2.3 的主要主题是完善在 2.2 中添加的一些功能、为核心语言添加各种小但实用的增强功能，以及扩展标准库。 上一版本引入的新对象模型已经受益于 18 个月的错误修复和优化努力，这些优化提升了新式类的性能。 新增了几个内置函数，例..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>Python 2.3 有什么新变化 &#8212; Python 3.14.0a4 文档</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=08c2cdb3" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=5349f25f" />
    
    <script src="../_static/documentation_options.js?v=495aad30"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=beaddf03"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.14.0a4 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于此文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权所有" href="../copyright.html" />
    <link rel="next" title="Python 2.2 有什么新变化" href="2.2.html" />
    <link rel="prev" title="Python 2.4 有什么新变化" href="2.4.html" />
    
      <script defer data-domain="docs.python.org" src="https://plausible.io/js/script.js"></script>
    
    <link rel="canonical" href="https://docs.python.org/3/whatsnew/2.3.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q" />
                <input type="submit" value="提交"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#">Python 2.3 有什么新变化</a><ul>
<li><a class="reference internal" href="#pep-218-a-standard-set-datatype">PEP 218: 标准集合数据类型</a></li>
<li><a class="reference internal" href="#pep-255-simple-generators">PEP 255: 简单的生成器</a></li>
<li><a class="reference internal" href="#pep-263-source-code-encodings">PEP 263: 源代码的字符编码格式</a></li>
<li><a class="reference internal" href="#pep-273-importing-modules-from-zip-archives">PEP 273: 从ZIP压缩包导入模块</a></li>
<li><a class="reference internal" href="#pep-277-unicode-file-name-support-for-windows-nt">PEP 277: 针对 Windows NT 的 Unicode 文件名支持</a></li>
<li><a class="reference internal" href="#pep-278-universal-newline-support">PEP 278: 通用换行支持</a></li>
<li><a class="reference internal" href="#pep-279-enumerate">PEP 279: enumerate()</a></li>
<li><a class="reference internal" href="#pep-282-the-logging-package">PEP 282: logging 包</a></li>
<li><a class="reference internal" href="#pep-285-a-boolean-type">PEP 285: 布尔类型</a></li>
<li><a class="reference internal" href="#pep-293-codec-error-handling-callbacks">PEP 293: 编解码器错误处理回调</a></li>
<li><a class="reference internal" href="#pep-301-package-index-and-metadata-for-distutils">PEP 301: Distutils的软件包索引和元数据</a></li>
<li><a class="reference internal" href="#pep-302-new-import-hooks">PEP 302: 新导入钩子</a></li>
<li><a class="reference internal" href="#pep-305-comma-separated-files">PEP 305: 逗号分隔文件</a></li>
<li><a class="reference internal" href="#pep-307-pickle-enhancements">PEP 307：对 pickle 的改进</a></li>
<li><a class="reference internal" href="#extended-slices">扩展切片</a></li>
<li><a class="reference internal" href="#other-language-changes">其他语言特性修改</a><ul>
<li><a class="reference internal" href="#string-changes">字符串的改变</a></li>
<li><a class="reference internal" href="#optimizations">性能优化</a></li>
</ul>
</li>
<li><a class="reference internal" href="#new-improved-and-deprecated-modules">新增，改进和弃用的模块</a><ul>
<li><a class="reference internal" href="#date-time-type">Date/Time 类型</a></li>
<li><a class="reference internal" href="#the-optparse-module">optparse 模块</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pymalloc-a-specialized-object-allocator">Pymalloc: A Specialized Object Allocator</a></li>
<li><a class="reference internal" href="#build-and-c-api-changes">构建和 C API 的改变</a><ul>
<li><a class="reference internal" href="#port-specific-changes">移植专属的改变</a></li>
</ul>
</li>
<li><a class="reference internal" href="#other-changes-and-fixes">其他的改变和修正</a></li>
<li><a class="reference internal" href="#porting-to-python-2-3">移植到 Python 2.3</a></li>
<li><a class="reference internal" href="#acknowledgements">致谢</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一主题</h4>
    <p class="topless"><a href="2.4.html"
                          title="上一章">Python 2.4 有什么新变化</a></p>
  </div>
  <div>
    <h4>下一主题</h4>
    <p class="topless"><a href="2.2.html"
                          title="下一章">Python 2.2 有什么新变化</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/whatsnew/2.3.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="2.2.html" title="Python 2.2 有什么新变化"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="2.4.html" title="Python 2.4 有什么新变化"
             accesskey="P">上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.14.0a4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python的新变化</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Python 2.3 有什么新变化</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q" id="search-box" />
          <input type="submit" value="提交" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="what-s-new-in-python-2-3">
<h1>Python 2.3 有什么新变化<a class="headerlink" href="#what-s-new-in-python-2-3" title="Link to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">作者<span class="colon">:</span></dt>
<dd class="field-odd"><p>A.M. Kuchling</p>
</dd>
</dl>
<p>本文介绍了 Python 2.3 的新特性。 Python 2.3 发布于 2003 年 7 月 29 日。</p>
<p>Python 2.3 的主要主题是完善在 2.2 中添加的一些功能、为核心语言添加各种小但实用的增强功能，以及扩展标准库。 上一版本引入的新对象模型已经受益于 18 个月的错误修复和优化努力，这些优化提升了新式类的性能。 新增了几个内置函数，例如 <a class="reference internal" href="../library/functions.html#sum" title="sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">sum()</span></code></a> 和 <a class="reference internal" href="../library/functions.html#enumerate" title="enumerate"><code class="xref py py-func docutils literal notranslate"><span class="pre">enumerate()</span></code></a>。 <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> 操作符现在可以用于子字符串搜索 (例如，<code class="docutils literal notranslate"><span class="pre">&quot;ab&quot;</span> <span class="pre">in</span> <span class="pre">&quot;abc&quot;</span></code> 将返回 <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>)。</p>
<p>许多新库功能包括布尔值、集合、堆、日期/时间数据类型，从ZIP格式的归档文件中导入模块的能力，期待已久的 Python 目录的元数据支持，更新版本的 IDLE，以及用于日志记录、文本包装、解析 CSV 文件、处理命令行选项、使用 BerkeleyDB 数据库的模块…… 新模块和增强模块的列表相当长。</p>
<p>本文并不试图提供对新功能的完整规范，而是提供了一个方便的概览。 有关详细信息，你应该参考 Python 2.3 的文档，例如 Python 库参考和 Python 参考手册。 如果你想了解完整的实现和设计原理，请参阅特定新功能的 PEP。</p>
<section id="pep-218-a-standard-set-datatype">
<h2>PEP 218: 标准集合数据类型<a class="headerlink" href="#pep-218-a-standard-set-datatype" title="Link to this heading">¶</a></h2>
<p>新的 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sets</span></code> 模块包含一个集合数据类型的实现。 <code class="xref py py-class docutils literal notranslate"><span class="pre">Set</span></code> 类用于可变集合，即可以添加和删除成员的集合。 <code class="xref py py-class docutils literal notranslate"><span class="pre">ImmutableSet</span></code> 类用于不可修改的集合，因此 <code class="xref py py-class docutils literal notranslate"><span class="pre">ImmutableSet</span></code> 的实例可以用作字典的键。 集合是基于字典构建的，因此集合中的元素必须是可哈希的。</p>
<p>这是一个简单的示例：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">sets</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">sets</span><span class="o">.</span><span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span>
<span class="go">Set([1, 2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="ow">in</span> <span class="n">S</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">0</span> <span class="ow">in</span> <span class="n">S</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span>
<span class="go">Set([1, 2, 5])</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>集合的并集和交集可以通过 <a class="reference internal" href="../library/stdtypes.html#frozenset.union" title="frozenset.union"><code class="xref py py-meth docutils literal notranslate"><span class="pre">union()</span></code></a> 和 <a class="reference internal" href="../library/stdtypes.html#frozenset.intersection" title="frozenset.intersection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">intersection()</span></code></a> 方法计算；另一种表示法是使用按位操作符 <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">|</span></code>。 可变集合还具有这些方法的原地版本，分别为 <code class="xref py py-meth docutils literal notranslate"><span class="pre">union_update()</span></code> 和 <a class="reference internal" href="../library/stdtypes.html#frozenset.intersection_update" title="frozenset.intersection_update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">intersection_update()</span></code></a>。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span> <span class="o">=</span> <span class="n">sets</span><span class="o">.</span><span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S2</span> <span class="o">=</span> <span class="n">sets</span><span class="o">.</span><span class="n">Set</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span>
<span class="go">Set([1, 2, 3, 4, 5, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span> <span class="o">|</span> <span class="n">S2</span>                  <span class="c1"># 替代写法</span>
<span class="go">Set([1, 2, 3, 4, 5, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span>
<span class="go">Set([])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span> <span class="o">&amp;</span> <span class="n">S2</span>                  <span class="c1"># 替代写法</span>
<span class="go">Set([])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span><span class="o">.</span><span class="n">union_update</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span>
<span class="go">Set([1, 2, 3, 4, 5, 6])</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>还可以计算两个集合的对称差集。 这是并集中不在交集中的所有元素。 换句话说，对称差集包含所有只在一个集合中的元素。 同样，还有一种替代表示法是使用按位操作符 (<code class="docutils literal notranslate"><span class="pre">^</span></code>)，并且有一个原地修改版本，名字比较长，叫 <a class="reference internal" href="../library/stdtypes.html#frozenset.symmetric_difference_update" title="frozenset.symmetric_difference_update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">symmetric_difference_update()</span></code></a>。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span> <span class="o">=</span> <span class="n">sets</span><span class="o">.</span><span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S2</span> <span class="o">=</span> <span class="n">sets</span><span class="o">.</span><span class="n">Set</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span><span class="o">.</span><span class="n">symmetric_difference</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span>
<span class="go">Set([1, 2, 5, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span> <span class="o">^</span> <span class="n">S2</span>
<span class="go">Set([1, 2, 5, 6])</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>另外还有 <code class="xref py py-meth docutils literal notranslate"><span class="pre">issubset()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">issuperset()</span></code> 方法用来检查一个集合是否为另一个集合的子集或超集:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span> <span class="o">=</span> <span class="n">sets</span><span class="o">.</span><span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S2</span> <span class="o">=</span> <span class="n">sets</span><span class="o">.</span><span class="n">Set</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S2</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">S1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-54"></span><a class="pep reference external" href="https://peps.python.org/pep-0218/"><strong>PEP 218</strong></a> - 添加内置Set对象类型</dt><dd><p>PEP 由 Greg V. Wilson 撰写 ; 由 Greg V. Wilson, Alex Martelli 和 GvR 实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-255-simple-generators">
<span id="section-generators"></span><h2>PEP 255: 简单的生成器<a class="headerlink" href="#pep-255-simple-generators" title="Link to this heading">¶</a></h2>
<p>在 Python 2.2 中，生成器作为一个可选特性被添加，需要通过 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">generators</span></code> 指令来启用。 在 2.3 版本中，生成器不再需要特别启用，现在总是存在；这意味着 <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 现在始终是一个关键字。 本节的其余部分是从《Python 2.2的新特性》文档中复制的生成器描述；如果你在 Python 2.2 发布时已经阅读过，可以跳过本节的其余部分。</p>
<p>你一定熟悉在 Python 或 C 语言中函数调用的工作方式。 当你调用一个函数时，它会获得一个私有命名空间，在这个命名空间中创建其局部变量。 当函数执行到 <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 语句时，这些局部变量会被销毁，并将结果值返回给调用者。 稍后对同一个函数的调用将获得一套全新的局部变量。 但是，如果局部变量在函数退出时不被丢弃呢？如果你可以在函数停止的地方稍后恢复执行呢？这就是生成器所提供的功能；它们可以被视为可恢复的函数。</p>
<p>这里是一个生成器函数的最简示例:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">generate_ints</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">i</span>
</pre></div>
</div>
<p>一个新的关键字 <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 被引入用于生成器。 任何包含 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 语句的函数都是生成器函数；这由 Python 的字节码编译器检测到，并因此对函数进行特殊编译。</p>
<p>当您调用生成器函数时，它不会返回一个单独的值；相反，它会返回一个支持迭代器协议的生成器对象。在执行 <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 语句时，生成器会输出 <code class="docutils literal notranslate"><span class="pre">i</span></code> 的值 ，类似于 <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 语句。 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 与 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code> 语句之间的最大区别在于，在到达 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 时，生成器的执行状态会暂停，并保留本地变量。 在下一次调用生成器 的 <code class="docutils literal notranslate"><span class="pre">.next()</span></code> 方法时，函数将在 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 语句之后立即恢复执行。 （由于复杂的原因，<code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 语句不允许在 <a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>...<code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code> 语句的 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code> 代码块内出现；有关 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 和异常之间交互的完整解释，请阅读 <span class="target" id="index-55"></span><a class="pep reference external" href="https://peps.python.org/pep-0255/"><strong>PEP 255</strong></a>。）</p>
<p>下面是 <code class="xref py py-func docutils literal notranslate"><span class="pre">generate_ints()</span></code> 生成器的用法示例:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span> <span class="o">=</span> <span class="n">generate_ints</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span>
<span class="go">&lt;generator object at 0x8117f90&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;stdin&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
  File <span class="nb">&quot;stdin&quot;</span>, line <span class="m">2</span>, in <span class="n">generate_ints</span>
<span class="gr">StopIteration</span>
</pre></div>
</div>
<p>你可以等价地写成 <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">generate_ints(5)</span></code> 或 <code class="docutils literal notranslate"><span class="pre">a,b,c</span> <span class="pre">=</span> <span class="pre">generate_ints(3)</span></code>。</p>
<p>在生成器函数内部， <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 语句只能不带值使用，并表示值的生成过程结束；之后，生成器不能再返回任何值。在生成器函数内部，带值的 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code>，例如 <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">5</span></code>，是语法错误。生成器结果的结束也可以通过手动引发 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 异常来指示，或者只是让执行流自然地从函数底部流出。</p>
<p>你可以通过编写自己的类并将生成器的所有局部变量存储为实例变量，手动实现生成器的效果。例如，返回一个整数列表可以通过将 <code class="docutils literal notranslate"><span class="pre">self.count</span></code> 设置为0，并让 <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-meth docutils literal notranslate"><span class="pre">next()</span></code></a> 方法递增 <code class="docutils literal notranslate"><span class="pre">self.count</span></code> 并返回它。然而，对于一个中等复杂的生成器，编写一个相应的类将会更加混乱。<code class="file docutils literal notranslate"><span class="pre">Lib/test/test_generators.py</span></code> 包含了一些更有趣的例子。其中最简单的一个使用生成器递归实现了树的中序遍历：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 一个递归地按顺序生成 Tree 叶子节点的生成器。</span>
<span class="k">def</span><span class="w"> </span><span class="nf">inorder</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">t</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inorder</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">left</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">x</span>
        <span class="k">yield</span> <span class="n">t</span><span class="o">.</span><span class="n">label</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inorder</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">right</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">x</span>
</pre></div>
</div>
<p>在 <code class="file docutils literal notranslate"><span class="pre">Lib/test/test_generators.py</span></code> 中还有另外两个例子，它们分别解决了N皇后问题（在$NxN$的棋盘上放置$N$个皇后，使得没有任何皇后威胁到其他皇后）和骑士巡游问题（在$NxN$的棋盘上，骑士访问每一个方格且不重复访问任何方格的路径）。</p>
<p>生成器的概念源自其他编程语言，尤其是 Icon（<a class="reference external" href="https://www2.cs.arizona.edu/icon/">https://www2.cs.arizona.edu/icon/</a> ），在 Icon 语言中，生成器的概念是核心。在 Icon 中，每个表达式和函数调用生成器的概念源自其他编程语言，尤其是 Icon。 在 Icon 中，每个表达式和函数调用都可以表现得像一个生成器。 以下是来自“Icon 编程语言概述”中的一个示例，展示了生成器的用法 <a class="reference external" href="https://www2.cs.arizona.edu/icon/docs/ipd266.htm">https://www2.cs.arizona.edu/icon/docs/ipd266.htm</a> ：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">sentence</span> <span class="o">:=</span> <span class="s2">&quot;Store it in the neighboring harbor&quot;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">:=</span> <span class="n">find</span><span class="p">(</span><span class="s2">&quot;or&quot;</span><span class="p">,</span> <span class="n">sentence</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="n">then</span> <span class="n">write</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>在Icon中，<code class="xref py py-func docutils literal notranslate"><span class="pre">find()</span></code> 函数返回子字符串&quot;or&quot;所在的索引：3、23、33。在 <a class="reference internal" href="../reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 语句中，<code class="docutils literal notranslate"><span class="pre">i</span></code> 首先被赋值为 3，但 3 小于 5，因此比较失败，Icon 会使用第二个值 23 进行重试。 23 大于 5，因此比较成功，代码将值 23 打印到屏幕上。</p>
<p>Python并不像Icon那样将生成器作为核心概念来采用。生成器被视为Python核心语言的一部分，但学习或使用它们并不是强制的；如果它们不能解决你遇到的问题，可以完全忽略它们。与Icon相比，Python接口的一个新颖特性是生成器的状态表示为一个具体的对象（迭代器），可以传递给其他函数或存储在数据结构中。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-56"></span><a class="pep reference external" href="https://peps.python.org/pep-0255/"><strong>PEP 255</strong></a> - 简单生成器</dt><dd><p>由 Neil Schemenauer, Tim Peters, Magnus Lie Hetland 撰写。 主要由 Neil Schemenauer 和 Tim Peters 实现，并包含来自 Python Labs 团队的修正。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-263-source-code-encodings">
<span id="section-encodings"></span><h2>PEP 263: 源代码的字符编码格式<a class="headerlink" href="#pep-263-source-code-encodings" title="Link to this heading">¶</a></h2>
<p>现在可以声明Python源文件使用不同的字符集编码。通过在源文件的第一行或第二行包含特定格式的注释来声明编码。例如，一个UTF-8文件可以这样声明：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: UTF-8 -*-</span>
</pre></div>
</div>
<p>如果没有这样的编码声明，默认使用7位ASCII编码。执行或导入包含8位字符的字符串字面量且没有编码声明的模块时，在Python 2.3中会触发 <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a> 警告；而在Python 2.4中，这将成为语法错误</p>
<p>编码声明只影响Unicode字符串字面量，这些字面量将使用指定的编码转换为Unicode。请注意，Python的标识符仍然限制为ASCII字符，因此变量名不能使用超出常规字母数字字符范围的字符。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-57"></span><a class="pep reference external" href="https://peps.python.org/pep-0263/"><strong>PEP 263</strong></a> - 定义 Python 源代码的编码格式</dt><dd><p>由 Marc-André Lemburg 和 Martin von Löwis 撰写 ; 由 Suzuki Hisao 和 Martin von Löwis 实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-273-importing-modules-from-zip-archives">
<h2>PEP 273: 从ZIP压缩包导入模块<a class="headerlink" href="#pep-273-importing-modules-from-zip-archives" title="Link to this heading">¶</a></h2>
<p>通过新的 <a class="reference internal" href="../library/zipimport.html#module-zipimport" title="zipimport: Support for importing Python modules from ZIP archives."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipimport</span></code></a> 模块增加了从 ZIP 格式归档文件导入模块的支持。 你不需要显式地导入模块；它将在 ZIP 归档文件名被添加到 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> 的情况下自动导入。 例如：</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">amk@nyman:~/src/python$ </span>unzip<span class="w"> </span>-l<span class="w"> </span>/tmp/example.zip
<span class="go">Archive:  /tmp/example.zip</span>
<span class="go">  Length     Date   Time    Name</span>
<span class="go"> --------    ----   ----    ----</span>
<span class="go">     8467  11-26-02 22:30   jwzthreading.py</span>
<span class="go"> --------                   -------</span>
<span class="go">     8467                   1 file</span>
<span class="gp">amk@nyman:~/src/python$ </span>./python
<span class="go">Python 2.3 (#1, Aug 1 2003, 19:54:32)</span>
<span class="go">&gt;&gt;&gt; import sys</span>
<span class="go">&gt;&gt;&gt; sys.path.insert(0, &#39;/tmp/example.zip&#39;)  # 将 .zip 文件添加到 path 的开头</span>
<span class="go">&gt;&gt;&gt; import jwzthreading</span>
<span class="go">&gt;&gt;&gt; jwzthreading.__file__</span>
<span class="go">&#39;/tmp/example.zip/jwzthreading.py&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>An entry in <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> can now be the filename of a ZIP archive. The ZIP
archive can contain any kind of files, but only files named <code class="file docutils literal notranslate"><span class="pre">*.py</span></code>,
<code class="file docutils literal notranslate"><span class="pre">*.pyc</span></code>, or <code class="file docutils literal notranslate"><span class="pre">*.pyo</span></code> can be imported.  If an archive only contains
<code class="file docutils literal notranslate"><span class="pre">*.py</span></code> files, Python will not attempt to modify the archive by adding the
corresponding <code class="file docutils literal notranslate"><span class="pre">*.pyc</span></code> file, meaning that if a ZIP archive doesn't contain
<code class="file docutils literal notranslate"><span class="pre">*.pyc</span></code> files, importing may be rather slow.</p>
<p>A path within the archive can also be specified to only import from a
subdirectory; for example, the path <code class="file docutils literal notranslate"><span class="pre">/tmp/example.zip/lib/</span></code> would only
import from the <code class="file docutils literal notranslate"><span class="pre">lib/</span></code> subdirectory within the archive.</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-58"></span><a class="pep reference external" href="https://peps.python.org/pep-0273/"><strong>PEP 273</strong></a> - 从 ZIP 压缩包导入模块</dt><dd><p>由James C. Ahlstrom撰写，并提供了一个实现。Python 2.3遵循 <span class="target" id="index-59"></span><a class="pep reference external" href="https://peps.python.org/pep-0273/"><strong>PEP 273</strong></a> 中的规范，但使用了Just van Rossum编写的实现，该实现利用了 <span class="target" id="index-60"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a> 中描述的导入钩子。有关新导入钩子的描述，请参见 <a class="reference internal" href="#section-pep302"><span class="std std-ref">PEP 302: 新导入钩子</span></a> 的相关部分。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-277-unicode-file-name-support-for-windows-nt">
<h2>PEP 277: 针对 Windows NT 的 Unicode 文件名支持<a class="headerlink" href="#pep-277-unicode-file-name-support-for-windows-nt" title="Link to this heading">¶</a></h2>
<p>在Windows NT、2000和XP上，系统将文件名存储为Unicode字符串。传统上，Python将文件名表示为字节字符串，这种方式不够完善，因为它会导致某些文件名无法访问。</p>
<p>Python now allows using arbitrary Unicode strings (within the limitations of the
file system) for all functions that expect file names, most notably the
<a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> built-in function. If a Unicode string is passed to
<a class="reference internal" href="../library/os.html#os.listdir" title="os.listdir"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.listdir()</span></code></a>, Python now returns a list of Unicode strings.  A new
function, <code class="xref py py-func docutils literal notranslate"><span class="pre">os.getcwdu()</span></code>, returns the current directory as a Unicode string.</p>
<p>字节串仍可被用作文件名，并且在 Windows 上 Python 将透明地使用 <code class="docutils literal notranslate"><span class="pre">mbcs</span></code> 编码格式将其转换为 Unicode。</p>
<p>Other systems also allow Unicode strings as file names but convert them to byte
strings before passing them to the system, which can cause a <a class="reference internal" href="../library/exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a>
to be raised. Applications can test whether arbitrary Unicode strings are
supported as file names by checking <a class="reference internal" href="../library/os.path.html#os.path.supports_unicode_filenames" title="os.path.supports_unicode_filenames"><code class="xref py py-attr docutils literal notranslate"><span class="pre">os.path.supports_unicode_filenames</span></code></a>,
a Boolean value.</p>
<p>在 MacOS 下，<a class="reference internal" href="../library/os.html#os.listdir" title="os.listdir"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.listdir()</span></code></a> 现在可以返回 Unicode 文件名。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-61"></span><a class="pep reference external" href="https://peps.python.org/pep-0277/"><strong>PEP 277</strong></a> - 针对 Windows NT 的 Unicode 文件名支持</dt><dd><p>由 Neil Hodgson 撰写 ; 由 Neil Hodgson, Martin von Löwis 和 Mark Hammond 实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-278-universal-newline-support">
<span id="index-8"></span><h2>PEP 278: 通用换行支持<a class="headerlink" href="#pep-278-universal-newline-support" title="Link to this heading">¶</a></h2>
<p>目前使用的三大操作系统是微软的 Windows、苹果的 Macintosh OS 和各种 Unix 衍生系统。跨平台工作的一个小麻烦是，这三个平台都使用不同的字符来标记文本文件中的行结束。Unix 使用换行符（ASCII 字符 10），MacOS 使用回车符（ASCII 字符 13），Windows 使用回车符加换行符的双字符序列。</p>
<p>Python 的文件对象现在可以支持与 Python 运行平台不同的行结束约定。使用 <code class="docutils literal notranslate"><span class="pre">'U'</span></code> 或 <code class="docutils literal notranslate"><span class="pre">'rU'</span></code> 模式打开文件将以 <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a> 模式打开文件供读取。 所有这三种行结束约定都将在各种文件方法如 <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code> 返回的字符串中翻译为 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>。</p>
<p>在导入模块和使用 <code class="xref py py-func docutils literal notranslate"><span class="pre">execfile()</span></code> 函数执行文件时，也会使用通用换行支持。 这意味着 Python 模块可以在所有三种操作系统之间共享，而无需转换行尾。</p>
<p>在编译 Python 时，可以通过在运行 Python 的 <strong class="program">configure</strong> 脚本时指定 <code class="xref std std-option docutils literal notranslate"><span class="pre">--without-universal-newlines</span></code> 开关禁用该功能。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-62"></span><a class="pep reference external" href="https://peps.python.org/pep-0278/"><strong>PEP 278</strong></a> - 通用换行支持</dt><dd><p>由 Jack Jansen 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-279-enumerate">
<span id="section-enumerate"></span><h2>PEP 279: enumerate()<a class="headerlink" href="#pep-279-enumerate" title="Link to this heading">¶</a></h2>
<p>新的内置函数 <a class="reference internal" href="../library/functions.html#enumerate" title="enumerate"><code class="xref py py-func docutils literal notranslate"><span class="pre">enumerate()</span></code></a> 将使某些循环更加清晰。 在 <code class="docutils literal notranslate"><span class="pre">enumerate(thing)</span></code> 中，如果 <em>thing</em> 是迭代器或序列，则返回一个迭代器，该迭代器将返回 <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">thing[0])</span></code>，<code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">thing[1])</span></code>，<code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">thing[2])</span></code>，以此类推。</p>
<p>改变一个列表中每个元素的常见写法看起来像是这样:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)):</span>
    <span class="n">item</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="c1"># ... 基于条目计算某个结果 ...</span>
    <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
</pre></div>
</div>
<p>可以使用 <a class="reference internal" href="../library/functions.html#enumerate" title="enumerate"><code class="xref py py-func docutils literal notranslate"><span class="pre">enumerate()</span></code></a> 重写为：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
    <span class="c1"># ... 基于条目计算某个结果 ...</span>
    <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-63"></span><a class="pep reference external" href="https://peps.python.org/pep-0279/"><strong>PEP 279</strong></a> - 内置函数 enumerate()</dt><dd><p>由 Raymond D. Hettinger 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-282-the-logging-package">
<h2>PEP 282: logging 包<a class="headerlink" href="#pep-282-the-logging-package" title="Link to this heading">¶</a></h2>
<p>Python 2.3 中新增了一个用于编写日志的标准软件包 <a class="reference internal" href="../library/logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a>。 它为生成日志输出提供了一个强大而灵活的机制，这些输出可以通过各种方式进行过滤和处理。用标准格式编写的配置文件可以用来控制程序的日志行为。 Python 包含的处理器可以将日志记录写入标准错误、文件或套接字，发送到系统日志，甚至通过电子邮件发送到特定地址；当然，您也可以编写自己的处理器类。</p>
<p>The <a class="reference internal" href="../library/logging.html#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> class is the primary class. Most application code will deal
with one or more <a class="reference internal" href="../library/logging.html#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> objects, each one used by a particular
subsystem of the application. Each <a class="reference internal" href="../library/logging.html#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> is identified by a name, and
names are organized into a hierarchy using <code class="docutils literal notranslate"><span class="pre">.</span></code>  as the component separator.
For example, you might have <a class="reference internal" href="../library/logging.html#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> instances named <code class="docutils literal notranslate"><span class="pre">server</span></code>,
<code class="docutils literal notranslate"><span class="pre">server.auth</span></code> and <code class="docutils literal notranslate"><span class="pre">server.network</span></code>.  The latter two instances are below
<code class="docutils literal notranslate"><span class="pre">server</span></code> in the hierarchy.  This means that if you turn up the verbosity for
<code class="docutils literal notranslate"><span class="pre">server</span></code> or direct <code class="docutils literal notranslate"><span class="pre">server</span></code> messages to a different handler, the changes
will also apply to records logged to <code class="docutils literal notranslate"><span class="pre">server.auth</span></code> and <code class="docutils literal notranslate"><span class="pre">server.network</span></code>.
There's also a root <a class="reference internal" href="../library/logging.html#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> that's the parent of all other loggers.</p>
<p>为了简化使用，<a class="reference internal" href="../library/logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> 包提供了一些始终使用根日志的便捷函数:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>

<span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Debugging information&#39;</span><span class="p">)</span>
<span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Informational message&#39;</span><span class="p">)</span>
<span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Warning:config file </span><span class="si">%s</span><span class="s1"> not found&#39;</span><span class="p">,</span> <span class="s1">&#39;server.conf&#39;</span><span class="p">)</span>
<span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Error occurred&#39;</span><span class="p">)</span>
<span class="n">logging</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s1">&#39;Critical error -- shutting down&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>这会产生以下输出:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">WARNING</span><span class="p">:</span><span class="n">root</span><span class="p">:</span><span class="ne">Warning</span><span class="p">:</span><span class="n">config</span> <span class="n">file</span> <span class="n">server</span><span class="o">.</span><span class="n">conf</span> <span class="ow">not</span> <span class="n">found</span>
<span class="n">ERROR</span><span class="p">:</span><span class="n">root</span><span class="p">:</span><span class="n">Error</span> <span class="n">occurred</span>
<span class="n">CRITICAL</span><span class="p">:</span><span class="n">root</span><span class="p">:</span><span class="n">Critical</span> <span class="n">error</span> <span class="o">--</span> <span class="n">shutting</span> <span class="n">down</span>
</pre></div>
</div>
<p>在默认配置中，信息和调试信息被忽略，输出被发送到标准错误。 你可以通过调用根日志记录器上的 <a class="reference internal" href="../library/logging.html#logging.Logger.setLevel" title="logging.Logger.setLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setLevel()</span></code></a> 方法来启用信息和调试信息的显示。</p>
<p>请注意 <a class="reference internal" href="../library/logging.html#logging.warning" title="logging.warning"><code class="xref py py-func docutils literal notranslate"><span class="pre">warning()</span></code></a> 调用使用了字符串格式化运算符；所有记录信息的函数都使用参数 <code class="docutils literal notranslate"><span class="pre">(msg,</span> <span class="pre">arg1,</span> <span class="pre">arg2,</span> <span class="pre">...)</span></code>，并记录 <code class="docutils literal notranslate"><span class="pre">msg</span> <span class="pre">%</span> <span class="pre">(arg1,</span> <span class="pre">arg2,</span> <span class="pre">...)</span></code> 产生的字符串。</p>
<p>还有一个 <a class="reference internal" href="../library/logging.html#logging.exception" title="logging.exception"><code class="xref py py-func docutils literal notranslate"><span class="pre">exception()</span></code></a> 函数可记录最近的回溯。如果为关键字参数 <em>exc_info</em> 指定了真值，其他函数也会记录回溯：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>    <span class="mi">1</span><span class="o">/</span><span class="mi">0</span>
    <span class="k">except</span><span class="p">:</span> <span class="n">logging</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s1">&#39;Problem recorded&#39;</span><span class="p">)</span>

<span class="n">f</span><span class="p">()</span>
</pre></div>
</div>
<p>这会产生以下输出:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ERROR</span><span class="p">:</span><span class="n">root</span><span class="p">:</span><span class="n">Problem</span> <span class="n">recorded</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;t.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">6</span><span class="p">,</span> <span class="ow">in</span> <span class="n">f</span>
    <span class="mi">1</span><span class="o">/</span><span class="mi">0</span>
<span class="ne">ZeroDivisionError</span><span class="p">:</span> <span class="n">integer</span> <span class="n">division</span> <span class="ow">or</span> <span class="n">modulo</span> <span class="n">by</span> <span class="n">zero</span>
</pre></div>
</div>
<p>Slightly more advanced programs will use a logger other than the root logger.
The <code class="docutils literal notranslate"><span class="pre">getLogger(name)</span></code> function is used to get a particular log, creating
it if it doesn't exist yet. <code class="docutils literal notranslate"><span class="pre">getLogger(None)</span></code> returns the root logger.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;server&#39;</span><span class="p">)</span>
 <span class="o">...</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Listening on port </span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
 <span class="o">...</span>
<span class="n">log</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s1">&#39;Disk full&#39;</span><span class="p">)</span>
 <span class="o">...</span>
</pre></div>
</div>
<p>日志记录通常会向上传播，因此 <code class="docutils literal notranslate"><span class="pre">server</span></code> 和 <code class="docutils literal notranslate"><span class="pre">root</span></code> 也会看到记录到 <code class="docutils literal notranslate"><span class="pre">server.auth</span></code> 的信息，但 <a class="reference internal" href="../library/logging.html#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> 可以通过将其 <a class="reference internal" href="../library/logging.html#logging.Logger.propagate" title="logging.Logger.propagate"><code class="xref py py-attr docutils literal notranslate"><span class="pre">propagate</span></code></a> 属性设置为 <a class="reference internal" href="../library/constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> 来避免这种情况。</p>
<p>There are more classes provided by the <a class="reference internal" href="../library/logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> package that can be
customized.  When a <a class="reference internal" href="../library/logging.html#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> instance is told to log a message, it
creates a <a class="reference internal" href="../library/logging.html#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> instance that is sent to any number of different
<a class="reference internal" href="../library/logging.html#logging.Handler" title="logging.Handler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handler</span></code></a> instances.  Loggers and handlers can also have an attached list
of filters, and each filter can cause the <a class="reference internal" href="../library/logging.html#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> to be ignored or
can modify the record before passing it along.  When they're finally output,
<a class="reference internal" href="../library/logging.html#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> instances are converted to text by a <a class="reference internal" href="../library/logging.html#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a>
class.  All of these classes can be replaced by your own specially written
classes.</p>
<p><a class="reference internal" href="../library/logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> 软件包具有所有这些功能，即使是最复杂的应用程序也能灵活运用。 本文仅是对其功能的不完整概述，因此请参阅软件包的参考文档了解所有细节。 阅读 <span class="target" id="index-64"></span><a class="pep reference external" href="https://peps.python.org/pep-0282/"><strong>PEP 282</strong></a> 也会有所帮助。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-65"></span><a class="pep reference external" href="https://peps.python.org/pep-0282/"><strong>PEP 282</strong></a> - Logging 系统</dt><dd><p>由 Vinay Sajip 和 Trent Mick 撰写 ; 由 Vinay Sajip 实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-285-a-boolean-type">
<span id="section-bool"></span><h2>PEP 285: 布尔类型<a class="headerlink" href="#pep-285-a-boolean-type" title="Link to this heading">¶</a></h2>
<p>Python 2.3 中增加了布尔类型。 <code class="xref py py-mod docutils literal notranslate"><span class="pre">__builtin__</span></code> 模块中新增了两个常量: <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> 和 <a class="reference internal" href="../library/constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>。 (<a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> 和 <a class="reference internal" href="../library/constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> 常量被添加到了 Python 2.2.1 的内置模块中，但 2.2.1 版本的常量只是被设置为 1 和 0 的整数值，并不是一种不同的类型。)</p>
<p>这个新类型的类型对象名为 <a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>；它的构造函数接收任何 Python 值，并将其转换为 <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> 或 <a class="reference internal" href="../library/constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>。:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">([])</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>大多数标准库模块和内置函数都改为返回布尔值：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;append&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>添加 Python 布尔运算的主要目的是使代码更清晰。 例如，如果您在阅读一个函数时遇到 <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">1</span></code> 语句，您可能会想知道 <code class="docutils literal notranslate"><span class="pre">1</span></code> 代表的是布尔真值、索引还是乘以其他量的系数。 然而，如果语句是 <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">True</span></code>，返回值的含义就非常清楚了。</p>
<p>Python 的布尔值 <em>不是</em> 为了严格的类型检查而添加的。 像 Pascal 这样非常严格的语言也会阻止您使用布尔进行算术运算，并要求 <a class="reference internal" href="../reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 语句中的表达式总是求布尔结果。 正如 <span class="target" id="index-66"></span><a class="pep reference external" href="https://peps.python.org/pep-0285/"><strong>PEP 285</strong></a> 所明确指出的，Python 没有这么严格，以后也不会有。 这意味着您仍然可以在 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code> 语句中使用任何表达式，甚至是求值为 list、tuple 或一些随机对象的表达式。 布尔类型是 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 类的子类，因此使用布尔值进行算术运算仍然有效：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kc">True</span> <span class="o">+</span> <span class="mi">1</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kc">False</span> <span class="o">+</span> <span class="mi">1</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kc">False</span> <span class="o">*</span> <span class="mi">75</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kc">True</span> <span class="o">*</span> <span class="mi">75</span>
<span class="go">75</span>
</pre></div>
</div>
<p>用一句话概括 <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> 和 <a class="reference internal" href="../library/constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>: 它们是拼写整数值 1 和 0 的另一种方式，唯一不同的是 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 和 <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 返回的字符串是 <code class="docutils literal notranslate"><span class="pre">'True'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">'False'</span></code>，而不是 <code class="docutils literal notranslate"><span class="pre">'1'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">'0'</span></code>。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-67"></span><a class="pep reference external" href="https://peps.python.org/pep-0285/"><strong>PEP 285</strong></a> - 添加布尔类型</dt><dd><p>由 GvR 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-293-codec-error-handling-callbacks">
<h2>PEP 293: 编解码器错误处理回调<a class="headerlink" href="#pep-293-codec-error-handling-callbacks" title="Link to this heading">¶</a></h2>
<p>将 Unicode 字符串编码为字节字符串时，可能会遇到无法编码的字符。 到目前为止，Python 允许将错误处理指定为 &quot;strict&quot; (引发 <a class="reference internal" href="../library/exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a>)、&quot;ignore&quot; (跳过该字符) 或 &quot;replace&quot; (在输出字符串中使用问号)，其中 &quot;strict&quot; 是默认行为。 可能需要指定对此类错误的其他处理方式，例如在转换后的字符串中插入 XML 字符引用或 HTML 实体引用。</p>
<p>Python 现在有一个灵活的框架，可以添加不同的处理策略。可以通过 <a class="reference internal" href="../library/codecs.html#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">codecs.register_error()</span></code></a> 添加新的错误处理器，然后编解码器可以通过 <a class="reference internal" href="../library/codecs.html#codecs.lookup_error" title="codecs.lookup_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">codecs.lookup_error()</span></code></a> 访问错误处理器。 错误处理器会获取必要的状态信息，如正在转换的字符串、字符串中检测到错误的位置以及目标编码。 然后，处理器可以引发异常或返回替换字符串。</p>
<p>使用该框架还实现了两个额外的错误处理器: &quot;backslashreplace&quot; 使用 Python 反斜杠引号来表示无法编码的字符，而 &quot;xmlcharrefreplace&quot; 则转换为 XML 字符引用。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-68"></span><a class="pep reference external" href="https://peps.python.org/pep-0293/"><strong>PEP 293</strong></a> - 编解码器错误处理回调</dt><dd><p>由 Walter Dörwald 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-301-package-index-and-metadata-for-distutils">
<span id="section-pep301"></span><h2>PEP 301: Distutils的软件包索引和元数据<a class="headerlink" href="#pep-301-package-index-and-metadata-for-distutils" title="Link to this heading">¶</a></h2>
<p>广受期待的对 Python 编目的支持在 2.3 版中首次出现。</p>
<p>编目功能的核心是新的 Distutils <strong class="command">register</strong> 命令。 运行 <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">register</span></code> 将会收集描述软件包的元数据，例如其名称、版本、维护者、描述信息等等，并将其发送给中央编目服务器。 结果编目数据可在 <a class="reference external" href="https://pypi.org">https://pypi.org</a> 获取。</p>
<p>为了使目录更加有用，Distutils 的 <code class="xref py py-func docutils literal notranslate"><span class="pre">setup()</span></code> 函数中新增了一个可选的 <em>classifiers</em> 关键字参数。 可以提供一系列 <a class="reference external" href="http://catb.org/~esr/trove/">Trove</a> 风格的字符串来帮助对软件进行分类。</p>
<p>下面是一个带有分类器的 <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> 示例，其编写是为了兼容旧版本的 Distutils：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">distutils</span><span class="w"> </span><span class="kn">import</span> <span class="n">core</span>
<span class="n">kw</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s2">&quot;Quixote&quot;</span><span class="p">,</span>
      <span class="s1">&#39;version&#39;</span><span class="p">:</span> <span class="s2">&quot;0.5.1&quot;</span><span class="p">,</span>
      <span class="s1">&#39;description&#39;</span><span class="p">:</span> <span class="s2">&quot;A highly Pythonic Web application framework&quot;</span><span class="p">,</span>
      <span class="c1"># ...</span>
      <span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">core</span><span class="p">,</span> <span class="s1">&#39;setup_keywords&#39;</span><span class="p">)</span> <span class="ow">and</span>
    <span class="s1">&#39;classifiers&#39;</span> <span class="ow">in</span> <span class="n">core</span><span class="o">.</span><span class="n">setup_keywords</span><span class="p">):</span>
    <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;classifiers&#39;</span><span class="p">]</span> <span class="o">=</span> \
        <span class="p">[</span><span class="s1">&#39;Topic :: Internet :: WWW/HTTP :: Dynamic Content&#39;</span><span class="p">,</span>
         <span class="s1">&#39;Environment :: No Input/Output (Daemon)&#39;</span><span class="p">,</span>
         <span class="s1">&#39;Intended Audience :: Developers&#39;</span><span class="p">],</span>

<span class="n">core</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>
</pre></div>
</div>
<p>完整的 classifiers 列表可通过运行 <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">register</span> <span class="pre">--list-classifiers</span></code> 来获取。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-69"></span><a class="pep reference external" href="https://peps.python.org/pep-0301/"><strong>PEP 301</strong></a> - Distutils 的软件包索引和元数据</dt><dd><p>由 Richard Jones 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-302-new-import-hooks">
<span id="section-pep302"></span><h2>PEP 302: 新导入钩子<a class="headerlink" href="#pep-302-new-import-hooks" title="Link to this heading">¶</a></h2>
<p>虽然自从在 Python 1.3 中引入 <code class="xref py py-mod docutils literal notranslate"><span class="pre">ihooks</span></code> 模块后，就可以编写自定义导入钩子了，但由于编写新的导入钩子既困难又混乱，所以从来没有人对它真正满意过。 曾有人提出过各种替代方案，如 <code class="xref py py-mod docutils literal notranslate"><span class="pre">imputil</span></code> 和 <code class="xref py py-mod docutils literal notranslate"><span class="pre">iu</span></code> 模块，但都没有得到广泛认可，而且都不容易从 C 代码中使用。</p>
<p><span class="target" id="index-70"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a> 借鉴了其前身，尤其是 Gordon McMillan 的 <code class="xref py py-mod docutils literal notranslate"><span class="pre">iu</span></code> 模块。 <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a> 模块新增了三个条目：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sys.path_hooks</span></code> 是一个可调用对象列表，通常是类。 每个可调用对象都接收一个包含路径的字符串，然后返回一个可处理从该路径导入的导入器对象，如果不能处理该路径，则引发 <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> 异常。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code> 会缓存每条路径的导入器对象，因此 <code class="docutils literal notranslate"><span class="pre">sys.path_hooks</span></code> 只需为每条路径遍历一次。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sys.meta_path</span></code> 是一个导入器对象列表，在检查 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> 之前将遍历该列表。 该列表最初为空，但用户代码可以向其中添加对象。 其他内置模块和冻结模块可以通过添加到该列表中的对象导入。</p></li>
</ul>
<p>导入器对象必须有一个方法，即 <code class="docutils literal notranslate"><span class="pre">find_module(fullname,</span> <span class="pre">path=None)</span></code>。 <em>fullname</em> 将是一个模块或软件包名称，如 <code class="docutils literal notranslate"><span class="pre">string</span></code> 或 <code class="docutils literal notranslate"><span class="pre">distutils.core</span></code>。 <code class="xref py py-meth docutils literal notranslate"><span class="pre">find_module()</span></code> 必须返回一个加载器对象，该加载器对象必须有一个方法 <code class="docutils literal notranslate"><span class="pre">load_module(fullname)</span></code>，用于创建和返回相应的模块对象。</p>
<p>因此，Python 新导入逻辑的伪代码如下 (略有简化；详情请参见 <span class="target" id="index-71"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a>)：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">mp</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="p">:</span>
    <span class="n">loader</span> <span class="o">=</span> <span class="n">mp</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">loader</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">load_module</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>

<span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">hook</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">path_hooks</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">importer</span> <span class="o">=</span> <span class="n">hook</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="c1"># ImportError，则尝试其他路径钩子</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loader</span> <span class="o">=</span> <span class="n">importer</span><span class="o">.</span><span class="n">find_module</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>
            <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">load_module</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>

<span class="c1"># 未找到！</span>
<span class="k">raise</span> <span class="ne">ImportError</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-72"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a> - 新导入钩</dt><dd><p>由 Just van Rossum 和 Paul Moore 撰写 ; 由 Just van Rossum 实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-305-comma-separated-files">
<span id="section-pep305"></span><h2>PEP 305: 逗号分隔文件<a class="headerlink" href="#pep-305-comma-separated-files" title="Link to this heading">¶</a></h2>
<p>以逗号作为分隔符的文件是一种常用于从数据库和电子表格导出数据的格式。 Python 2.3 增加了一个针对逗号分隔文件的解析器。</p>
<p>逗号分隔文件乍一看非常简单:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Costs</span><span class="p">,</span><span class="mi">150</span><span class="p">,</span><span class="mi">200</span><span class="p">,</span><span class="mf">3.95</span>
</pre></div>
</div>
<p>读取一行并调用 <code class="docutils literal notranslate"><span class="pre">line.split(',')</span></code>: 再简单不过了吧？ 但是考虑到可能包含逗号的字符串数据，事件就变得复杂起来:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;Costs&quot;</span><span class="p">,</span><span class="mi">150</span><span class="p">,</span><span class="mi">200</span><span class="p">,</span><span class="mf">3.95</span><span class="p">,</span><span class="s2">&quot;Includes taxes, shipping, and sundry items&quot;</span>
</pre></div>
</div>
<p>一个大的丑陋的正则表达式可以解析这些内容，但使用新的 <a class="reference internal" href="../library/csv.html#module-csv" title="csv: Write and read tabular data to and from delimited files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">csv</span></code></a> 软件包要简单得多：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">csv</span>

<span class="nb">input</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;datafile&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
<span class="n">reader</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">reader</span><span class="p">:</span>
    <span class="nb">print</span> <span class="n">line</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/csv.html#csv.reader" title="csv.reader"><code class="xref py py-func docutils literal notranslate"><span class="pre">reader()</span></code></a> 函数有多种不同的选项。 字段分隔符不限于逗号，可以改为任何字符，引号和行尾字符也是如此。</p>
<p>Different dialects of comma-separated files can be defined and registered;
currently there are two dialects, both used by Microsoft Excel. A separate
<a class="reference internal" href="../library/csv.html#csv.writer" title="csv.writer"><code class="xref py py-class docutils literal notranslate"><span class="pre">csv.writer</span></code></a> class will generate comma-separated files from a succession
of tuples or lists, quoting strings that contain the delimiter.</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt>该实现在“Python 增强提议” - PEP <cite>305</cite> (CSV 文件 API)  中被提出</dt><dd><p>由 Kevin Altis, Dave Cole, Andrew McNamara, Skip Montanaro, Cliff Wells 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-307-pickle-enhancements">
<span id="section-pep307"></span><h2>PEP 307：对 pickle 的改进<a class="headerlink" href="#pep-307-pickle-enhancements" title="Link to this heading">¶</a></h2>
<p><a class="reference internal" href="../library/pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 和 <code class="xref py py-mod docutils literal notranslate"><span class="pre">cPickle</span></code> 模块在 2.3 开发周期中受到了关注。 在 2.2 中，新式类的 pickle 并不困难，但 pickle 得并不紧凑；<span class="target" id="index-73"></span><a class="pep reference external" href="https://peps.python.org/pep-0307/"><strong>PEP 307</strong></a> 引用了一个微不足道的例子，在这个例子中，新式类的 pickle 字符串比经典类的 pickle 字符串长三倍。</p>
<p>解决办法就是发明一种新的 pickle 协议。 <a class="reference internal" href="../library/pickle.html#pickle.dumps" title="pickle.dumps"><code class="xref py py-func docutils literal notranslate"><span class="pre">pickle.dumps()</span></code></a> 函数很早就支持文本或二进制标志。 在 2.3 中，该标志从布尔值重新定义为整数：0 表示旧的文本模式 pickle 格式，1 表示旧的二进制格式，现在 2 表示新的 2.3 专用格式。 一个新常量 <a class="reference internal" href="../library/pickle.html#pickle.HIGHEST_PROTOCOL" title="pickle.HIGHEST_PROTOCOL"><code class="xref py py-const docutils literal notranslate"><span class="pre">pickle.HIGHEST_PROTOCOL</span></code></a> 可用来选择最先进的协议。</p>
<p>unpickle 不再被视为安全操作。 2.2 的 <a class="reference internal" href="../library/pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 提供了钩子，试图阻止不安全的类被 unpickle （特别是 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__safe_for_unpickling__</span></code> 属性），但这些代码都没有经过审计，因此在 2.3 中都被删除了。 在任何版本的 Python 中，您都不应该 unpickle 不信任的数据。</p>
<p>To reduce the pickling overhead for new-style classes, a new interface for
customizing pickling was added using three special methods:
<a class="reference internal" href="../library/pickle.html#object.__getstate__" title="object.__getstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getstate__()</span></code></a>, <a class="reference internal" href="../library/pickle.html#object.__setstate__" title="object.__setstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setstate__()</span></code></a>, and <a class="reference internal" href="../library/pickle.html#object.__getnewargs__" title="object.__getnewargs__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getnewargs__()</span></code></a>.  Consult
<span class="target" id="index-22"></span><a class="pep reference external" href="https://peps.python.org/pep-0307/"><strong>PEP 307</strong></a> for the full semantics  of these methods.</p>
<p>为了进一步压缩 pickle 类，现在可以使用整数代码而不是长字符串来标识 pickle 类。 Python 软件基金会将维护一个标准化代码列表；还有一系列供私人使用的代码。 目前还没有指定任何代码。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-74"></span><a class="pep reference external" href="https://peps.python.org/pep-0307/"><strong>PEP 307</strong></a> - pickle 协议的扩展</dt><dd><p>PEP 由 Guido van Rossum 和 Tim Peters 撰写和实现。</p>
</dd>
</dl>
</div>
</section>
<section id="extended-slices">
<span id="section-slices"></span><h2>扩展切片<a class="headerlink" href="#extended-slices" title="Link to this heading">¶</a></h2>
<p>从 Python 1.4 开始，切片语法支持可选的第三个“step”或“stride”参数。例如，这些都是合法的 Python 语法: <code class="docutils literal notranslate"><span class="pre">L[1:10:2]</span></code>，<code class="docutils literal notranslate"><span class="pre">L[:-1:1]</span></code>，<code class="docutils literal notranslate"><span class="pre">L[::-1]</span></code>。 这是应 Numerical Python 开发者的要求添加到 Python 中的，因为 Numerical Python 广泛使用第三个参数。 然而，Python 内置的 list、tuple 和字符串序列类型从未支持过这一特性，如果您尝试使用，会引发 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。 Michael Hudson 提供了一个补丁来修复这一缺陷。</p>
<p>例如，您现在可以轻松地提取出具有偶数索引的列表元素：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[0, 2, 4, 6, 8]</span>
</pre></div>
</div>
<p>也可以用负值以按相反顺序复制相同的列表：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span>
</pre></div>
</div>
<p>这也适用于元组、数组和字符串：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">=</span><span class="s1">&#39;abcd&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
<span class="go">&#39;ac&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">&#39;dcba&#39;</span>
</pre></div>
</div>
<p>如果你有一个可变序列如列表或数组，你可以对扩展切片进行赋值或删除，但对扩展切片的赋值与对常规切片的赋值有一些区别。对常规片段的赋值可以用来改变序列的长度：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[0, 1, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[0, 4, 5, 6]</span>
</pre></div>
</div>
<p>扩展分片则没有这种灵活性。 在为扩展分片赋值时，语句右侧的列表必须包含与要替换的分片相同数量的项目：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[0, 1, 2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[0, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[0, 1, -1, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
<span class="gr">ValueError</span>: <span class="n">attempt to assign sequence of size 3 to extended slice of size 2</span>
</pre></div>
</div>
<p>删除操作更为直观：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[0, 1, 2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[0, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">a</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[1, 3]</span>
</pre></div>
</div>
<p>现在，我们还可以将切片对象传递给内置序列的 <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 方法：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">[0, 2, 4]</span>
</pre></div>
</div>
<p>或者直接在下标中使用切片对象：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="go">[0, 2, 4]</span>
</pre></div>
</div>
<p>为了简化支持扩展切片的序列的实现，切片对象现在有了一个方法 <code class="docutils literal notranslate"><span class="pre">indices(length)</span></code>，在给定序列长度的情况下，它返回一个 <code class="docutils literal notranslate"><span class="pre">(start,</span> <span class="pre">stop,</span> <span class="pre">step)</span></code> 元组，可以直接传给 <a class="reference internal" href="../library/stdtypes.html#range" title="range"><code class="xref py py-func docutils literal notranslate"><span class="pre">range()</span></code></a>。 <code class="xref py py-meth docutils literal notranslate"><span class="pre">indices()</span></code> 处理省略和越界索引的方式与常规切片一致（这个无伤大雅的短语隐藏了大量令人困惑的细节！）。 该方法的使用方法如下：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">FakeSeq</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calc_item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="o">...</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">FakeSeq</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_item</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">indices</span><span class="p">)])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_item</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>从这个例子中还可以看到，内置的 <a class="reference internal" href="../library/functions.html#slice" title="slice"><code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code></a> 对象现在是 slice 类型的类型对象，而不再是函数。 这与 Python 2.2 是一致的，在 Python 2.2 中，<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>，<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 等也经历了同样的变化。</p>
</section>
<section id="other-language-changes">
<h2>其他语言特性修改<a class="headerlink" href="#other-language-changes" title="Link to this heading">¶</a></h2>
<p>以下是 Python 2.3 针对核心 Python 语言的所有改变。</p>
<ul>
<li><p><a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 语句现在将始终是关键字，如本文档的 <a class="reference internal" href="#section-generators"><span class="std std-ref">PEP 255: 简单的生成器</span></a> 一节所描述的。</p></li>
<li><p>新增内置函数 <a class="reference internal" href="../library/functions.html#enumerate" title="enumerate"><code class="xref py py-func docutils literal notranslate"><span class="pre">enumerate()</span></code></a>，如本文档的 <a class="reference internal" href="#section-enumerate"><span class="std std-ref">PEP 279: enumerate()</span></a> 一节所描述的。</p></li>
<li><p>新增两个常量 <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> 和 <a class="reference internal" href="../library/constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> 以及内置的 <a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a> 类型，如本文档的 <a class="reference internal" href="#section-bool"><span class="std std-ref">PEP 285: 布尔类型</span></a> 一节所描述的。</p></li>
<li><p><a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> 类型构造函数现在会返回一个长整数，而不会在字符串或浮点数太大而无法放入整数时引发 <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a>。 这可能会导致 <code class="docutils literal notranslate"><span class="pre">isinstance(int(expression),</span> <span class="pre">int)</span></code> 为假的矛盾结果，但在实践中似乎不太可能造成问题。</p></li>
<li><p>内置类型现在支持扩展的切分语法，详见本文档 <a class="reference internal" href="#section-slices"><span class="std std-ref">扩展切片</span></a> 一节。</p></li>
<li><p>A new built-in function, <code class="docutils literal notranslate"><span class="pre">sum(iterable,</span> <span class="pre">start=0)</span></code>,  adds up the numeric
items in the iterable object and returns their sum.  <a class="reference internal" href="../library/functions.html#sum" title="sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">sum()</span></code></a> only accepts
numbers, meaning that you can't use it to concatenate a bunch of strings.
(Contributed by Alex Martelli.)</p></li>
<li><p>以前 <code class="docutils literal notranslate"><span class="pre">list.insert(pos,</span> <span class="pre">value)</span></code> 在 <em>pos</em> 为负值时会将 <em>value</em> 插入到列表的前面。 现在，该行为已被修改为与切片索引一致，因此当 <em>pos</em> 为 -1 时，值将被插入最后一个元素之前，以此类推。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">list.index(value)</span></code> 会在列表中搜索 <em>value</em>，并返回其索引，现在可以使用可选的 <em>start</em> 和 <em>stop</em> 参数，将搜索范围限制在列表的一部分。</p></li>
<li><p>字典有一个新方法 <code class="docutils literal notranslate"><span class="pre">pop(key[,</span> <span class="pre">*default*])</span></code>，可返回 <em>key</em> 对应的值，并从字典中删除该键/值对。如果请求的键不在字典中，如果指定了 <em>default</em>，则返回 <em>default</em>，如果没有指定则会引发 <a class="reference internal" href="../library/exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a>。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">{1: 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;stdin&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
<span class="gr">KeyError</span>: <span class="n">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;stdin&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
<span class="gr">KeyError</span>: <span class="n">&#39;pop(): dictionary is empty&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">{}</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>还有一个新的类方法 <code class="docutils literal notranslate"><span class="pre">dict.fromkeys(iterable,</span> <span class="pre">value)</span></code>，用于创建一个字典，其键取自所提供的迭代器 <em>iterable</em>，所有值设置为 <em>value</em>，默认为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p>（由 Raymond Hettinger 贡献补丁。）</p>
<p>此外，现在 <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-func docutils literal notranslate"><span class="pre">dict()</span></code></a> 构建器可接受关键字参数以简化小型字典的创建:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">dict</span><span class="p">(</span><span class="n">red</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">blue</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">green</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">black</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">{&#39;blue&#39;: 2, &#39;black&#39;: 4, &#39;green&#39;: 3, &#39;red&#39;: 1}</span>
</pre></div>
</div>
<p>（由 Just van Rossum 贡献。）</p>
</li>
<li><p><a class="reference internal" href="../reference/simple_stmts.html#assert"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">assert</span></code></a> 语句将不再检查 <code class="docutils literal notranslate"><span class="pre">__debug__</span></code> 旗标，因此你无法再通过为 <code class="docutils literal notranslate"><span class="pre">__debug__</span></code> 赋值来禁用断言。 使用 <a class="reference internal" href="../using/cmdline.html#cmdoption-O"><code class="xref std std-option docutils literal notranslate"><span class="pre">-O</span></code></a> 开关运行 Python 仍会生成不执行任何断言的代码。</p></li>
<li><p>大多数类型对象现在都是可调用的，因此您可以用它们来创建新对象，如函数、类和模块。（这意味着 <code class="xref py py-mod docutils literal notranslate"><span class="pre">new</span></code> 模块可以在未来的 Python 版本中被废弃，因为您现在可以使用 <a class="reference internal" href="../library/types.html#module-types" title="types: Names for built-in types."><code class="xref py py-mod docutils literal notranslate"><span class="pre">types</span></code></a> 模块中可用的类型对象）。例如，您可以用下面的代码创建一个新的模块对象：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">types</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">ModuleType</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">,</span><span class="s1">&#39;docstring&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">&lt;module &#39;abc&#39; (built-in)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="vm">__doc__</span>
<span class="go">&#39;docstring&#39;</span>
</pre></div>
</div>
</li>
<li><p>添加了一个新的警告 <a class="reference internal" href="../library/exceptions.html#PendingDeprecationWarning" title="PendingDeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PendingDeprecationWarning</span></code></a>，用于指示正在被废弃的功能。 默认情况下 <em>不会</em> 打印该警告。 要检查是否使用了将来会被废弃的功能，可在命令行中提供 <a class="reference internal" href="../using/cmdline.html#cmdoption-W"><code class="xref std std-option docutils literal notranslate"><span class="pre">-Walways::PendingDeprecationWarning::</span></code></a> 或使用 <a class="reference internal" href="../library/warnings.html#warnings.filterwarnings" title="warnings.filterwarnings"><code class="xref py py-func docutils literal notranslate"><span class="pre">warnings.filterwarnings()</span></code></a>。</p></li>
<li><p>与 <code class="docutils literal notranslate"><span class="pre">raise</span> <span class="pre">&quot;Error</span> <span class="pre">occurred&quot;</span></code> 一样，基于字符串的异常的废弃过程已经开始。 现在，引发字符串异常将触发 <a class="reference internal" href="../library/exceptions.html#PendingDeprecationWarning" title="PendingDeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PendingDeprecationWarning</span></code></a>。</p></li>
<li><p>现在使用 <code class="docutils literal notranslate"><span class="pre">None</span></code> 作为变量名将导致 <a class="reference internal" href="../library/exceptions.html#SyntaxWarning" title="SyntaxWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxWarning</span></code></a> 警告。 在未来的 Python 版本中，<code class="docutils literal notranslate"><span class="pre">None</span></code> 将最终成为一个保留关键字。</p></li>
<li><p>在 Python 2.1 中引入的文件对象的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">xreadlines()</span></code> 方法已不再需要，因为文件现在可以作为自己的迭代器来运行。 引入 <code class="xref py py-meth docutils literal notranslate"><span class="pre">xreadlines()</span></code> 的初衷是为了更快地循环遍历文件中的所有行，但现在只需写入 <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">line</span> <span class="pre">in</span> <span class="pre">file_obj</span></code> 即可。 文件对象还有一个新的只读 <code class="xref py py-attr docutils literal notranslate"><span class="pre">encoding</span></code> 属性，它给出了文件使用的编码；写入文件的 Unicode 字符串将使用给定的编码自动转换为字节。</p></li>
<li><p>新式类使用的方法解析顺序发生了变化，不过只有在继承层次结构非常复杂的情况下，你才会注意到这种差异。 经典类不受这一变化的影响。 Python 2.2 最初使用类祖先的拓扑排序，但 2.3 现在使用 C3 算法，如论文 <a class="reference external" href="https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.3910">&quot;A Monotonic Superclass Linearization for Dylan&quot;</a> 所述。 要了解这一变化的动机，请阅读 Michele Simionato 的文章 <a class="reference internal" href="../howto/mro.html#python-2-3-mro"><span class="std std-ref">Python 2.3 方法解析顺序</span></a>，或阅读 python-dev 上从 <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2002-October/029035.html">https://mail.python.org/pipermail/python-dev/2002-October/029035.html</a> 开始的消息。 Samuele Pedroni 首先指出了这个问题，并通过编码 C3 算法实现了修复。</p></li>
<li><p>Python 运行多线程程序时，会在执行 N 个字节码后切换线程。 N 的默认值已从 10 个字节码增加到 100 个，通过减少切换开销来加快单线程应用程序的速度。 一些多线程应用程序的响应时间可能会变慢，但这很容易解决，只需使用 <code class="docutils literal notranslate"><span class="pre">sys.setcheckinterval(N)</span></code> 将限制设回一个较低的数值即可。 使用新的 <code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getcheckinterval()</span></code> 函数可以检索限制值。</p></li>
<li><p>一个微小但影响深远的变化是，由 Python 附带的模块定义的扩展类型的名称现在包含模块和类型名称前面的 <code class="docutils literal notranslate"><span class="pre">'.'</span></code>。 例如，在 Python 2.2 中，如果你创建了一个套接字并打印了它的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__class__</span></code>，你会得到这样的输出：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="vm">__class__</span>
<span class="go">&lt;type &#39;socket&#39;&gt;</span>
</pre></div>
</div>
<p>在 2.3 中，您会得到以下信息：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="vm">__class__</span>
<span class="go">&lt;type &#39;_socket.socket&#39;&gt;</span>
</pre></div>
</div>
</li>
<li><p>One of the noted incompatibilities between old- and new-style classes has been
removed: you can now assign to the <a class="reference internal" href="../reference/datamodel.html#type.__name__" title="type.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> and <a class="reference internal" href="../reference/datamodel.html#type.__bases__" title="type.__bases__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__bases__</span></code></a>
attributes of new-style classes.  There are some restrictions on what can be
assigned to <code class="xref py py-attr docutils literal notranslate"><span class="pre">__bases__</span></code> along the lines of those relating to assigning to
an instance's <a class="reference internal" href="../reference/datamodel.html#object.__class__" title="object.__class__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__class__</span></code></a> attribute.</p></li>
</ul>
<section id="string-changes">
<h3>字符串的改变<a class="headerlink" href="#string-changes" title="Link to this heading">¶</a></h3>
<ul>
<li><p><a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> 运算符现在对字符串的作用不同了。 以前，当计算 <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">in</span> <span class="pre">Y</span></code> 时，<em>X</em> 和 <em>Y</em> 都是字符串，<em>X</em> 只能是单字符。 现在情况有所改变；<em>X</em> 可以是任意长度的字符串，如果 <em>X</em> 是 <em>Y</em> 的子串，<code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">in</span> <span class="pre">Y</span></code> 将返回 <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>。 如果 <em>X</em> 是空字符串，结果总是 <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;ab&#39;</span> <span class="ow">in</span> <span class="s1">&#39;abcd&#39;</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;ad&#39;</span> <span class="ow">in</span> <span class="s1">&#39;abcd&#39;</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;&#39;</span> <span class="ow">in</span> <span class="s1">&#39;abcd&#39;</span>
<span class="go">True</span>
</pre></div>
</div>
<p>请注意，这不会告诉您子串从哪里开始；如果需要该信息，请使用字符串方法 <a class="reference internal" href="../library/stdtypes.html#str.find" title="str.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find()</span></code></a>。</p>
</li>
<li><p><a class="reference internal" href="../library/stdtypes.html#str.strip" title="str.strip"><code class="xref py py-meth docutils literal notranslate"><span class="pre">strip()</span></code></a>、<a class="reference internal" href="../library/stdtypes.html#str.lstrip" title="str.lstrip"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lstrip()</span></code></a> 和 <a class="reference internal" href="../library/stdtypes.html#str.rstrip" title="str.rstrip"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rstrip()</span></code></a> 字符串方法现在有了一个可选参数，用于指定要删除的字符。默认值仍然是删除所有空白字符：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;   abc &#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
<span class="go">&#39;abc&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;&gt;&lt;&gt;&lt;abc&lt;&gt;&lt;&gt;&lt;&gt;&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;&lt;&gt;&#39;</span><span class="p">)</span>
<span class="go">&#39;abc&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;&gt;&lt;&gt;&lt;abc&lt;&gt;&lt;&gt;&lt;&gt;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;&lt;&gt;&#39;</span><span class="p">)</span>
<span class="go">&#39;abc&lt;&gt;&lt;&gt;&lt;&gt;\n&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">u</span><span class="s1">&#39;</span><span class="se">\u4000\u4001</span><span class="s1">abc</span><span class="se">\u4000</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="sa">u</span><span class="s1">&#39;</span><span class="se">\u4000</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">u&#39;\u4001abc&#39;</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>（由 Simon Brunning 提议并由 Walter Dörwald 实现。）</p>
</li>
<li><p><a class="reference internal" href="../library/stdtypes.html#str.startswith" title="str.startswith"><code class="xref py py-meth docutils literal notranslate"><span class="pre">startswith()</span></code></a> 和 <a class="reference internal" href="../library/stdtypes.html#str.endswith" title="str.endswith"><code class="xref py py-meth docutils literal notranslate"><span class="pre">endswith()</span></code></a> 字符串方法的 <em>start</em> 和 <em>end</em> 参数现在可接受负数。</p></li>
<li><p>另一个新增的字符串方法是 <a class="reference internal" href="../library/stdtypes.html#str.zfill" title="str.zfill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">zfill()</span></code></a>，原本是 <a class="reference internal" href="../library/string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code></a> 模块中的一个函数。 <a class="reference internal" href="../library/stdtypes.html#str.zfill" title="str.zfill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">zfill()</span></code></a> 会在一个表示数字的字符串左侧填充零直至达到指定的宽度。 请注意 <code class="docutils literal notranslate"><span class="pre">%</span></code> 运算符相比 <a class="reference internal" href="../library/stdtypes.html#str.zfill" title="str.zfill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">zfill()</span></code></a> 仍然是更灵活和更强大的。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;45&#39;</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">&#39;0045&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;12345&#39;</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">&#39;12345&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;goofy&#39;</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">&#39;0goofy&#39;</span>
</pre></div>
</div>
<p>（由 Walter Dörwald 贡献。）</p>
</li>
<li><p>A new type object, <code class="xref py py-class docutils literal notranslate"><span class="pre">basestring</span></code>, has been added. Both 8-bit strings and
Unicode strings inherit from this type, so <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">basestring)</span></code> will
return <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> for either kind of string.  It's a completely abstract
type, so you can't create <code class="xref py py-class docutils literal notranslate"><span class="pre">basestring</span></code> instances.</p></li>
<li><p>Interned strings are no longer immortal and will now be garbage-collected in
the usual way when the only reference to them is from the internal dictionary of
interned strings.  (Implemented by Oren Tirosh.)</p></li>
</ul>
</section>
<section id="optimizations">
<h3>性能优化<a class="headerlink" href="#optimizations" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>新式类实例的创建速度获得大幅提升；现在已经比经典类更快了！</p></li>
<li><p>列表对象的 <a class="reference internal" href="../library/stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort()</span></code></a> 方面已被 Tim Peters 全面改写，其实现的运行速度显著提高。</p></li>
<li><p>Multiplication of large long integers is now much faster thanks to an
implementation of Karatsuba multiplication, an algorithm that scales better than
the <em>O</em>(<em>n</em><sup>2</sup>) required for the grade-school multiplication algorithm.  (Original
patch by Christopher A. Craig, and significantly reworked by Tim Peters.)</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">SET_LINENO</span></code> opcode is now gone.  This may provide a small speed
increase, depending on your compiler's idiosyncrasies. See section
<a class="reference internal" href="#section-other"><span class="std std-ref">其他的改变和修正</span></a> for a longer explanation. (Removed by Michael Hudson.)</p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">xrange()</span></code> objects now have their own iterator, making <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span>
<span class="pre">xrange(n)</span></code> slightly faster than <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">range(n)</span></code>.  (Patch by Raymond
Hettinger.)</p></li>
<li><p>A number of small rearrangements have been made in various hotspots to improve
performance, such as inlining a function or removing some code.  (Implemented
mostly by GvR, but lots of people have contributed single changes.)</p></li>
</ul>
<p>2.3 优化的总体结果是 Python 2.3 运行 pystone 基准测试的速度比 Python 2.2 加快了大约 25%。</p>
</section>
</section>
<section id="new-improved-and-deprecated-modules">
<h2>新增，改进和弃用的模块<a class="headerlink" href="#new-improved-and-deprecated-modules" title="Link to this heading">¶</a></h2>
<p>As usual, Python's standard library received a number of enhancements and bug
fixes.  Here's a partial list of the most notable changes, sorted alphabetically
by module name. Consult the <code class="file docutils literal notranslate"><span class="pre">Misc/NEWS</span></code> file in the source tree for a more
complete list of changes, or look through the CVS logs for all the details.</p>
<ul>
<li><p>The <a class="reference internal" href="../library/array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal notranslate"><span class="pre">array</span></code></a> module now supports arrays of Unicode characters using the
<code class="docutils literal notranslate"><span class="pre">'u'</span></code> format character.  Arrays also now support using the <code class="docutils literal notranslate"><span class="pre">+=</span></code> assignment
operator to add another array's contents, and the <code class="docutils literal notranslate"><span class="pre">*=</span></code> assignment operator to
repeat an array. (Contributed by Jason Orendorff.)</p></li>
<li><p>The <code class="xref py py-mod docutils literal notranslate"><span class="pre">bsddb</span></code> module has been replaced by version 4.1.6 of the <a class="reference external" href="https://pybsddb.sourceforge.net">PyBSDDB</a> package, providing a more complete interface
to the transactional features of the BerkeleyDB library.</p>
<p>The old version of the module has been renamed to  <code class="xref py py-mod docutils literal notranslate"><span class="pre">bsddb185</span></code> and is no
longer built automatically; you'll  have to edit <code class="file docutils literal notranslate"><span class="pre">Modules/Setup</span></code> to enable
it.  Note that the new <code class="xref py py-mod docutils literal notranslate"><span class="pre">bsddb</span></code> package is intended to be compatible with
the  old module, so be sure to file bugs if you discover any incompatibilities.
When upgrading to Python 2.3, if the new interpreter is compiled with a new
version of  the underlying BerkeleyDB library, you will almost certainly have to
convert your database files to the new version.  You can do this fairly easily
with the new scripts <code class="file docutils literal notranslate"><span class="pre">db2pickle.py</span></code> and <code class="file docutils literal notranslate"><span class="pre">pickle2db.py</span></code> which you
will find in the distribution's <code class="file docutils literal notranslate"><span class="pre">Tools/scripts</span></code> directory.  If you've
already been using the PyBSDDB package and importing it as <code class="xref py py-mod docutils literal notranslate"><span class="pre">bsddb3</span></code>, you
will have to change your <code class="docutils literal notranslate"><span class="pre">import</span></code> statements to import it as <code class="xref py py-mod docutils literal notranslate"><span class="pre">bsddb</span></code>.</p>
</li>
<li><p>The new <a class="reference internal" href="../library/bz2.html#module-bz2" title="bz2: Interfaces for bzip2 compression and decompression."><code class="xref py py-mod docutils literal notranslate"><span class="pre">bz2</span></code></a> module is an interface to the bz2 data compression library.
bz2-compressed data is usually smaller than  corresponding
<a class="reference internal" href="../library/zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a>-compressed data. (Contributed by Gustavo Niemeyer.)</p></li>
<li><p>A set of standard date/time types has been added in the new <a class="reference internal" href="../library/datetime.html#module-datetime" title="datetime: Basic date and time types."><code class="xref py py-mod docutils literal notranslate"><span class="pre">datetime</span></code></a>
module.  See the following section for more details.</p></li>
<li><p>The Distutils <code class="xref py py-class docutils literal notranslate"><span class="pre">Extension</span></code> class now supports an extra constructor
argument named <em>depends</em> for listing additional source files that an extension
depends on.  This lets Distutils recompile the module if any of the dependency
files are modified.  For example, if <code class="file docutils literal notranslate"><span class="pre">sampmodule.c</span></code> includes the header
file <code class="file docutils literal notranslate"><span class="pre">sample.h</span></code>, you would create the <code class="xref py py-class docutils literal notranslate"><span class="pre">Extension</span></code> object like
this:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ext</span> <span class="o">=</span> <span class="n">Extension</span><span class="p">(</span><span class="s2">&quot;samp&quot;</span><span class="p">,</span>
                <span class="n">sources</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sampmodule.c&quot;</span><span class="p">],</span>
                <span class="n">depends</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sample.h&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>修改 <code class="file docutils literal notranslate"><span class="pre">sample.h</span></code> 将导致模块被重新编译。 （由 Jeremy Hylton 贡献。）</p>
</li>
<li><p>对 Distutils 的其他小修改：现在它会检查 <span class="target" id="index-75"></span><a class="reference internal" href="../using/configure.html#envvar-CC"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">CC</span></code></a>, <span class="target" id="index-76"></span><a class="reference internal" href="../using/configure.html#envvar-CFLAGS"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">CFLAGS</span></code></a>, <code class="xref std std-envvar docutils literal notranslate"><span class="pre">CPP</span></code>, <span class="target" id="index-77"></span><a class="reference internal" href="../using/configure.html#envvar-LDFLAGS"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">LDFLAGS</span></code></a> 和 <span class="target" id="index-78"></span><a class="reference internal" href="../using/configure.html#envvar-CPPFLAGS"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">CPPFLAGS</span></code></a> 环境变量，使用它们来覆盖 Python 配置中的设置（由 Robert Weber 贡献）。</p></li>
<li><p>Previously the <a class="reference internal" href="../library/doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> module would only search the docstrings of
public methods and functions for test cases, but it now also examines private
ones as well.  The <a class="reference internal" href="../library/doctest.html#doctest.DocTestSuite" title="doctest.DocTestSuite"><code class="xref py py-func docutils literal notranslate"><span class="pre">DocTestSuite()</span></code></a> function creates a
<a class="reference internal" href="../library/unittest.html#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestSuite</span></code></a> object from a set of <a class="reference internal" href="../library/doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> tests.</p></li>
<li><p>新的 <code class="docutils literal notranslate"><span class="pre">gc.get_referents(object)</span></code> 函数将返回由 <em>object</em> 引用的所有对象组成的列表。</p></li>
<li><p>The <a class="reference internal" href="../library/getopt.html#module-getopt" title="getopt: Portable parser for command line options; support both short and long option names."><code class="xref py py-mod docutils literal notranslate"><span class="pre">getopt</span></code></a> module gained a new function, <a class="reference internal" href="../library/getopt.html#getopt.gnu_getopt" title="getopt.gnu_getopt"><code class="xref py py-func docutils literal notranslate"><span class="pre">gnu_getopt()</span></code></a>, that
supports the same arguments as the existing <a class="reference internal" href="../library/getopt.html#getopt.getopt" title="getopt.getopt"><code class="xref py py-func docutils literal notranslate"><span class="pre">getopt()</span></code></a> function but uses
GNU-style scanning mode. The existing <a class="reference internal" href="../library/getopt.html#getopt.getopt" title="getopt.getopt"><code class="xref py py-func docutils literal notranslate"><span class="pre">getopt()</span></code></a> stops processing options as
soon as a non-option argument is encountered, but in GNU-style mode processing
continues, meaning that options and arguments can be mixed.  For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getopt</span><span class="o">.</span><span class="n">getopt</span><span class="p">([</span><span class="s1">&#39;-f&#39;</span><span class="p">,</span> <span class="s1">&#39;filename&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">,</span> <span class="s1">&#39;-v&#39;</span><span class="p">],</span> <span class="s1">&#39;f:v&#39;</span><span class="p">)</span>
<span class="go">([(&#39;-f&#39;, &#39;filename&#39;)], [&#39;output&#39;, &#39;-v&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getopt</span><span class="o">.</span><span class="n">gnu_getopt</span><span class="p">([</span><span class="s1">&#39;-f&#39;</span><span class="p">,</span> <span class="s1">&#39;filename&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">,</span> <span class="s1">&#39;-v&#39;</span><span class="p">],</span> <span class="s1">&#39;f:v&#39;</span><span class="p">)</span>
<span class="go">([(&#39;-f&#39;, &#39;filename&#39;), (&#39;-v&#39;, &#39;&#39;)], [&#39;output&#39;])</span>
</pre></div>
</div>
<p>（由 Peter Åstrand 贡献。）</p>
</li>
<li><p>现在 <a class="reference internal" href="../library/grp.html#module-grp" title="grp: The group database (getgrnam() and friends). (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">grp</span></code></a>, <a class="reference internal" href="../library/pwd.html#module-pwd" title="pwd: The password database (getpwnam() and friends). (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pwd</span></code></a> 和 <a class="reference internal" href="../library/resource.html#module-resource" title="resource: An interface to provide resource usage information on the current process. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">resource</span></code></a> 模块将返回加强版的元组:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">grp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">grp</span><span class="o">.</span><span class="n">getgrnam</span><span class="p">(</span><span class="s1">&#39;amk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">gr_name</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">gr_gid</span>
<span class="go">(&#39;amk&#39;, 500)</span>
</pre></div>
</div>
</li>
<li><p>现在 <a class="reference internal" href="../library/gzip.html#module-gzip" title="gzip: Interfaces for gzip compression and decompression using file objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gzip</span></code></a> 模块能够处理超过 2 GiB 的文件。</p></li>
<li><p>The new <a class="reference internal" href="../library/heapq.html#module-heapq" title="heapq: Heap queue algorithm (a.k.a. priority queue)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">heapq</span></code></a> module contains an implementation of a heap queue
algorithm.  A heap is an array-like data structure that keeps items in a
partially sorted order such that, for every index <em>k</em>, <code class="docutils literal notranslate"><span class="pre">heap[k]</span> <span class="pre">&lt;=</span>
<span class="pre">heap[2*k+1]</span></code> and <code class="docutils literal notranslate"><span class="pre">heap[k]</span> <span class="pre">&lt;=</span> <span class="pre">heap[2*k+2]</span></code>.  This makes it quick to remove the
smallest item, and inserting a new item while maintaining the heap property is
<em>O</em>(log <em>n</em>).  (See <a class="reference external" href="https://xlinux.nist.gov/dads//HTML/priorityque.html">https://xlinux.nist.gov/dads//HTML/priorityque.html</a> for more
information about the priority queue data structure.)</p>
<p>The <a class="reference internal" href="../library/heapq.html#module-heapq" title="heapq: Heap queue algorithm (a.k.a. priority queue)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">heapq</span></code></a> module provides <a class="reference internal" href="../library/heapq.html#heapq.heappush" title="heapq.heappush"><code class="xref py py-func docutils literal notranslate"><span class="pre">heappush()</span></code></a> and <a class="reference internal" href="../library/heapq.html#heapq.heappop" title="heapq.heappop"><code class="xref py py-func docutils literal notranslate"><span class="pre">heappop()</span></code></a> functions
for adding and removing items while maintaining the heap property on top of some
other mutable Python sequence type.  Here's an example that uses a Python list:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">heap</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
<span class="gp">... </span>   <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">heap</span>
<span class="go">[1, 3, 5, 11, 7]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">heap</span>
<span class="go">[5, 7, 11]</span>
</pre></div>
</div>
<p>（由 Kevin O'Connor 贡献。）</p>
</li>
<li><p>The IDLE integrated development environment has been updated using the code
from the IDLEfork project (<a class="reference external" href="https://idlefork.sourceforge.net">https://idlefork.sourceforge.net</a>).  The most notable feature is
that the code being developed is now executed in a subprocess, meaning that
there's no longer any need for manual <code class="docutils literal notranslate"><span class="pre">reload()</span></code> operations. IDLE's core code
has been incorporated into the standard library as the <a class="reference internal" href="../library/idle.html#module-idlelib" title="idlelib: Implementation package for the IDLE shell/editor."><code class="xref py py-mod docutils literal notranslate"><span class="pre">idlelib</span></code></a> package.</p></li>
<li><p>The <a class="reference internal" href="../library/imaplib.html#module-imaplib" title="imaplib: IMAP4 protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">imaplib</span></code></a> module now supports IMAP over SSL. (Contributed by Piers
Lauder and Tino Lange.)</p></li>
<li><p>The <a class="reference internal" href="../library/itertools.html#module-itertools" title="itertools: Functions creating iterators for efficient looping."><code class="xref py py-mod docutils literal notranslate"><span class="pre">itertools</span></code></a> contains a number of useful functions for use with
iterators, inspired by various functions provided by the ML and Haskell
languages.  For example, <code class="docutils literal notranslate"><span class="pre">itertools.ifilter(predicate,</span> <span class="pre">iterator)</span></code> returns all
elements in the iterator for which the function <code class="xref py py-func docutils literal notranslate"><span class="pre">predicate()</span></code> returns
<a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>, and <code class="docutils literal notranslate"><span class="pre">itertools.repeat(obj,</span> <span class="pre">N)</span></code> returns <code class="docutils literal notranslate"><span class="pre">obj</span></code> <em>N</em> times.
There are a number of other functions in the module; see the package's reference
documentation for details.
(Contributed by Raymond Hettinger.)</p></li>
<li><p>Two new functions in the <a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> module, <code class="docutils literal notranslate"><span class="pre">degrees(rads)</span></code> and
<code class="docutils literal notranslate"><span class="pre">radians(degs)</span></code>, convert between radians and degrees.  Other functions in
the <a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> module such as <a class="reference internal" href="../library/math.html#math.sin" title="math.sin"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.sin()</span></code></a> and <a class="reference internal" href="../library/math.html#math.cos" title="math.cos"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.cos()</span></code></a> have always
required input values measured in radians.  Also, an optional <em>base</em> argument
was added to <a class="reference internal" href="../library/math.html#math.log" title="math.log"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.log()</span></code></a> to make it easier to compute logarithms for bases
other than <code class="docutils literal notranslate"><span class="pre">e</span></code> and <code class="docutils literal notranslate"><span class="pre">10</span></code>.  (Contributed by Raymond Hettinger.)</p></li>
<li><p>Several new POSIX functions (<code class="xref py py-func docutils literal notranslate"><span class="pre">getpgid()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">killpg()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">lchown()</span></code>,
<code class="xref py py-func docutils literal notranslate"><span class="pre">loadavg()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">major()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">makedev()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">minor()</span></code>, and
<code class="xref py py-func docutils literal notranslate"><span class="pre">mknod()</span></code>) were added to the <a class="reference internal" href="../library/posix.html#module-posix" title="posix: The most common POSIX system calls (normally used via module os). (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">posix</span></code></a> module that underlies the
<a class="reference internal" href="../library/os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os</span></code></a> module. (Contributed by Gustavo Niemeyer, Geert Jansen, and Denis S.
Otkidach.)</p></li>
<li><p>In the <a class="reference internal" href="../library/os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os</span></code></a> module, the <code class="xref py py-func docutils literal notranslate"><span class="pre">*stat()</span></code> family of functions can now report
fractions of a second in a timestamp.  Such time stamps are represented as
floats, similar to the value returned by <a class="reference internal" href="../library/time.html#time.time" title="time.time"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.time()</span></code></a>.</p>
<p>During testing, it was found that some applications will break if time stamps
are floats.  For compatibility, when using the tuple interface of the
<a class="reference internal" href="../library/os.html#os.stat_result" title="os.stat_result"><code class="xref py py-class docutils literal notranslate"><span class="pre">stat_result</span></code></a> time stamps will be represented as integers. When using
named fields (a feature first introduced in Python 2.2), time stamps are still
represented as integers, unless <code class="xref py py-func docutils literal notranslate"><span class="pre">os.stat_float_times()</span></code> is invoked to enable
float return values:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="s2">&quot;/tmp&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">st_mtime</span>
<span class="go">1034791200</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">stat_float_times</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="s2">&quot;/tmp&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">st_mtime</span>
<span class="go">1034791200.6335014</span>
</pre></div>
</div>
<p>在 Python 2.4 中，默认将改为总是返回浮点数。</p>
<p>Application developers should enable this feature only if all their libraries
work properly when confronted with floating-point time stamps, or if they use
the tuple API. If used, the feature should be activated on an application level
instead of trying to enable it on a per-use basis.</p>
</li>
<li><p>The <a class="reference internal" href="../library/optparse.html#module-optparse" title="optparse: Command-line option parsing library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">optparse</span></code></a> module contains a new parser for command-line arguments
that can convert option values to a particular Python type  and will
automatically generate a usage message.  See the following section for  more
details.</p></li>
<li><p>The old and never-documented <code class="xref py py-mod docutils literal notranslate"><span class="pre">linuxaudiodev</span></code> module has been deprecated,
and a new version named <code class="xref py py-mod docutils literal notranslate"><span class="pre">ossaudiodev</span></code> has been added.  The module was
renamed because the OSS sound drivers can be used on platforms other than Linux,
and the interface has also been tidied and brought up to date in various ways.
(Contributed by Greg Ward and Nicholas FitzRoy-Dale.)</p></li>
<li><p>The new <a class="reference internal" href="../library/platform.html#module-platform" title="platform: Retrieves as much platform identifying data as possible."><code class="xref py py-mod docutils literal notranslate"><span class="pre">platform</span></code></a> module contains a number of functions that try to
determine various properties of the platform you're running on.  There are
functions for getting the architecture, CPU type, the Windows OS version, and
even the Linux distribution version. (Contributed by Marc-André Lemburg.)</p></li>
<li><p>The parser objects provided by the <a class="reference internal" href="../library/pyexpat.html#module-xml.parsers.expat" title="xml.parsers.expat: An interface to the Expat non-validating XML parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyexpat</span></code></a> module can now optionally
buffer character data, resulting in fewer calls to your character data handler
and therefore faster performance.  Setting the parser object's
<a class="reference internal" href="../library/pyexpat.html#xml.parsers.expat.xmlparser.buffer_text" title="xml.parsers.expat.xmlparser.buffer_text"><code class="xref py py-attr docutils literal notranslate"><span class="pre">buffer_text</span></code></a> attribute to <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> will enable buffering.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">sample(population,</span> <span class="pre">k)</span></code> function was added to the <a class="reference internal" href="../library/random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">random</span></code></a>
module.  <em>population</em> is a sequence or <code class="xref py py-class docutils literal notranslate"><span class="pre">xrange</span></code> object containing the
elements of a population, and <a class="reference internal" href="../library/random.html#random.sample" title="random.sample"><code class="xref py py-func docutils literal notranslate"><span class="pre">sample()</span></code></a> chooses <em>k</em> elements from the
population without replacing chosen elements.  <em>k</em> can be any value up to
<code class="docutils literal notranslate"><span class="pre">len(population)</span></code>. For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">days</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Mo&#39;</span><span class="p">,</span> <span class="s1">&#39;Tu&#39;</span><span class="p">,</span> <span class="s1">&#39;We&#39;</span><span class="p">,</span> <span class="s1">&#39;Th&#39;</span><span class="p">,</span> <span class="s1">&#39;Fr&#39;</span><span class="p">,</span> <span class="s1">&#39;St&#39;</span><span class="p">,</span> <span class="s1">&#39;Sn&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">days</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>      <span class="c1"># 选择 3 个元素</span>
<span class="go">[&#39;St&#39;, &#39;Sn&#39;, &#39;Th&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">days</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>      <span class="c1"># 选择 7 个元素</span>
<span class="go">[&#39;Tu&#39;, &#39;Th&#39;, &#39;Mo&#39;, &#39;We&#39;, &#39;St&#39;, &#39;Fr&#39;, &#39;Sn&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">days</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>      <span class="c1"># 再次选择 7 个</span>
<span class="go">[&#39;We&#39;, &#39;Mo&#39;, &#39;Sn&#39;, &#39;Fr&#39;, &#39;Tu&#39;, &#39;St&#39;, &#39;Th&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">days</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>      <span class="c1"># 无法选择八个</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
  File <span class="nb">&quot;random.py&quot;</span>, line <span class="m">414</span>, in <span class="n">sample</span>
<span class="w">    </span>  <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s2">&quot;sample larger than population&quot;</span>
<span class="gr">ValueError</span>: <span class="n">sample larger than population</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">10000</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="mi">10</span><span class="p">)</span>   <span class="c1"># Choose ten odd nos. under 10000</span>
<span class="go">[3407, 3805, 1505, 7023, 2401, 2267, 9733, 3151, 8083, 9195]</span>
</pre></div>
</div>
<p>现在 <a class="reference internal" href="../library/random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">random</span></code></a> 模块使用新的“梅森旋转”算法，并以 C 实现。 它的速度更快并且与之前的算法相比研究更充分。</p>
<p>（所有改变均由 Raymond Hettinger 贡献。）</p>
</li>
<li><p><a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">readline</span></code></a> 模块也增加了几个新函数: <a class="reference internal" href="../library/readline.html#readline.get_history_item" title="readline.get_history_item"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_history_item()</span></code></a>, <a class="reference internal" href="../library/readline.html#readline.get_current_history_length" title="readline.get_current_history_length"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_current_history_length()</span></code></a> 和 <a class="reference internal" href="../library/readline.html#readline.redisplay" title="readline.redisplay"><code class="xref py py-func docutils literal notranslate"><span class="pre">redisplay()</span></code></a>。</p></li>
<li><p>The <code class="xref py py-mod docutils literal notranslate"><span class="pre">rexec</span></code> and <code class="xref py py-mod docutils literal notranslate"><span class="pre">Bastion</span></code> modules have been declared dead, and
attempts to import them will fail with a <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>.  New-style classes
provide new ways to break out of the restricted execution environment provided
by <code class="xref py py-mod docutils literal notranslate"><span class="pre">rexec</span></code>, and no one has interest in fixing them or time to do so.  If
you have applications using <code class="xref py py-mod docutils literal notranslate"><span class="pre">rexec</span></code>, rewrite them to use something else.</p>
<p>(Sticking with Python 2.2 or 2.1 will not make your applications any safer
because there are known bugs in the <code class="xref py py-mod docutils literal notranslate"><span class="pre">rexec</span></code> module in those versions.  To
repeat: if you're using <code class="xref py py-mod docutils literal notranslate"><span class="pre">rexec</span></code>, stop using it immediately.)</p>
</li>
<li><p>The <code class="xref py py-mod docutils literal notranslate"><span class="pre">rotor</span></code> module has been deprecated because the  algorithm it uses for
encryption is not believed to be secure.  If you need encryption, use one of the
several AES Python modules that are available separately.</p></li>
<li><p>The <a class="reference internal" href="../library/shutil.html#module-shutil" title="shutil: High-level file operations, including copying."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shutil</span></code></a> module gained a <code class="docutils literal notranslate"><span class="pre">move(src,</span> <span class="pre">dest)</span></code> function that
recursively moves a file or directory to a new location.</p></li>
<li><p>Support for more advanced POSIX signal handling was added to the <a class="reference internal" href="../library/signal.html#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal notranslate"><span class="pre">signal</span></code></a>
but then removed again as it proved impossible to make it work reliably across
platforms.</p></li>
<li><p>The <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> module now supports timeouts.  You can call the
<code class="docutils literal notranslate"><span class="pre">settimeout(t)</span></code> method on a socket object to set a timeout of <em>t</em> seconds.
Subsequent socket operations that take longer than <em>t</em> seconds to complete will
abort and raise a <a class="reference internal" href="../library/socket.html#socket.timeout" title="socket.timeout"><code class="xref py py-exc docutils literal notranslate"><span class="pre">socket.timeout</span></code></a> exception.</p>
<p>The original timeout implementation was by Tim O'Malley.  Michael Gilfix
integrated it into the Python <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> module and shepherded it through a
lengthy review.  After the code was checked in, Guido van Rossum rewrote parts
of it.  (This is a good example of a collaborative development process in
action.)</p>
</li>
<li><p>在 Windows，<a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> 模块现在将附带安全套接字层（SSL）支持。</p></li>
<li><p>现在 C <code class="xref c c-macro docutils literal notranslate"><span class="pre">PYTHON_API_VERSION</span></code> 宏的值将在 Python 层级上暴露为 <code class="docutils literal notranslate"><span class="pre">sys.api_version</span></code>。 当前的异常可通过调用新的 <code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_clear()</span></code> 函数来清除。</p></li>
<li><p>The new <a class="reference internal" href="../library/tarfile.html#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tarfile</span></code></a> module  allows reading from and writing to
<strong class="program">tar</strong>-format archive files. (Contributed by Lars Gustäbel.)</p></li>
<li><p>The new <a class="reference internal" href="../library/textwrap.html#module-textwrap" title="textwrap: Text wrapping and filling"><code class="xref py py-mod docutils literal notranslate"><span class="pre">textwrap</span></code></a> module contains functions for wrapping strings
containing paragraphs of text.  The <code class="docutils literal notranslate"><span class="pre">wrap(text,</span> <span class="pre">width)</span></code> function takes a
string and returns a list containing the text split into lines of no more than
the chosen width.  The <code class="docutils literal notranslate"><span class="pre">fill(text,</span> <span class="pre">width)</span></code> function returns a single
string, reformatted to fit into lines no longer than the chosen width. (As you
can guess, <a class="reference internal" href="../library/textwrap.html#textwrap.fill" title="textwrap.fill"><code class="xref py py-func docutils literal notranslate"><span class="pre">fill()</span></code></a> is built on top of <a class="reference internal" href="../library/textwrap.html#textwrap.wrap" title="textwrap.wrap"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap()</span></code></a>.  For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">textwrap</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">paragraph</span> <span class="o">=</span> <span class="s2">&quot;Not a whit, we defy augury: ... more text ...&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">textwrap</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">paragraph</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span>
<span class="go">[&quot;Not a whit, we defy augury: there&#39;s a special providence in&quot;,</span>
<span class="go"> &quot;the fall of a sparrow. If it be now, &#39;tis not to come; if it&quot;,</span>
<span class="go"> ...]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">paragraph</span><span class="p">,</span> <span class="mi">35</span><span class="p">)</span>
<span class="go">Not a whit, we defy augury: there&#39;s</span>
<span class="go">a special providence in the fall of</span>
<span class="go">a sparrow. If it be now, &#39;tis not</span>
<span class="go">to come; if it be not to come, it</span>
<span class="go">will be now; if it be not now, yet</span>
<span class="go">it will come: the readiness is all.</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>The module also contains a <a class="reference internal" href="../library/textwrap.html#textwrap.TextWrapper" title="textwrap.TextWrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextWrapper</span></code></a> class that actually implements
the text wrapping strategy.   Both the <a class="reference internal" href="../library/textwrap.html#textwrap.TextWrapper" title="textwrap.TextWrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextWrapper</span></code></a> class and the
<a class="reference internal" href="../library/textwrap.html#textwrap.wrap" title="textwrap.wrap"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap()</span></code></a> and <a class="reference internal" href="../library/textwrap.html#textwrap.fill" title="textwrap.fill"><code class="xref py py-func docutils literal notranslate"><span class="pre">fill()</span></code></a> functions support a number of additional keyword
arguments for fine-tuning the formatting; consult the module's documentation
for details. (Contributed by Greg Ward.)</p>
</li>
<li><p>The <code class="xref py py-mod docutils literal notranslate"><span class="pre">thread</span></code> and <a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> modules now have companion modules,
<code class="xref py py-mod docutils literal notranslate"><span class="pre">dummy_thread</span></code> and <code class="xref py py-mod docutils literal notranslate"><span class="pre">dummy_threading</span></code>, that provide a do-nothing
implementation of the <code class="xref py py-mod docutils literal notranslate"><span class="pre">thread</span></code> module's interface for platforms where
threads are not supported.  The intention is to simplify thread-aware modules
(ones that <em>don't</em> rely on threads to run) by putting the following code at the
top:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">threading</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_threading</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">dummy_threading</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_threading</span>
</pre></div>
</div>
<p>In this example, <code class="xref py py-mod docutils literal notranslate"><span class="pre">_threading</span></code> is used as the module name to make it clear
that the module being used is not necessarily the actual <a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a>
module. Code can call functions and use classes in <code class="xref py py-mod docutils literal notranslate"><span class="pre">_threading</span></code> whether or
not threads are supported, avoiding an <a class="reference internal" href="../reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> statement and making the
code slightly clearer.  This module will not magically make multithreaded code
run without threads; code that waits for another thread to return or to do
something will simply hang forever.</p>
</li>
<li><p>The <a class="reference internal" href="../library/time.html#module-time" title="time: Time access and conversions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">time</span></code></a> module's <a class="reference internal" href="../library/time.html#time.strptime" title="time.strptime"><code class="xref py py-func docutils literal notranslate"><span class="pre">strptime()</span></code></a> function has long been an annoyance
because it uses the platform C library's <a class="reference internal" href="../library/time.html#time.strptime" title="time.strptime"><code class="xref py py-func docutils literal notranslate"><span class="pre">strptime()</span></code></a> implementation, and
different platforms sometimes have odd bugs.  Brett Cannon contributed a
portable implementation that's written in pure Python and should behave
identically on all platforms.</p></li>
<li><p>The new <a class="reference internal" href="../library/timeit.html#module-timeit" title="timeit: Measure the execution time of small code snippets."><code class="xref py py-mod docutils literal notranslate"><span class="pre">timeit</span></code></a> module helps measure how long snippets of Python code
take to execute.  The <code class="file docutils literal notranslate"><span class="pre">timeit.py</span></code> file can be run directly from the
command line, or the module's <a class="reference internal" href="../library/timeit.html#timeit.Timer" title="timeit.Timer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Timer</span></code></a> class can be imported and used
directly.  Here's a short example that figures out whether it's faster to
convert an 8-bit string to Unicode by appending an empty Unicode string to it or
by using the <code class="xref py py-func docutils literal notranslate"><span class="pre">unicode()</span></code> function:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">timeit</span>

<span class="n">timer1</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">Timer</span><span class="p">(</span><span class="s1">&#39;unicode(&quot;abc&quot;)&#39;</span><span class="p">)</span>
<span class="n">timer2</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">Timer</span><span class="p">(</span><span class="s1">&#39;&quot;abc&quot; + u&quot;&quot;&#39;</span><span class="p">)</span>

<span class="c1"># Run three trials</span>
<span class="nb">print</span> <span class="n">timer1</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">repeat</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="mi">100000</span><span class="p">)</span>
<span class="nb">print</span> <span class="n">timer2</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">repeat</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="mi">100000</span><span class="p">)</span>

<span class="c1"># On my laptop this outputs:</span>
<span class="c1"># [0.36831796169281006, 0.37441694736480713, 0.35304892063140869]</span>
<span class="c1"># [0.17574405670166016, 0.18193507194519043, 0.17565798759460449]</span>
</pre></div>
</div>
</li>
<li><p>The <code class="xref py py-mod docutils literal notranslate"><span class="pre">Tix</span></code> module has received various bug fixes and updates for the
current version of the Tix package.</p></li>
<li><p>The <code class="xref py py-mod docutils literal notranslate"><span class="pre">Tkinter</span></code> module now works with a thread-enabled  version of Tcl.
Tcl's threading model requires that widgets only be accessed from the thread in
which they're created; accesses from another thread can cause Tcl to panic.  For
certain Tcl interfaces, <code class="xref py py-mod docutils literal notranslate"><span class="pre">Tkinter</span></code> will now automatically avoid this  when a
widget is accessed from a different thread by marshalling a command, passing it
to the correct thread, and waiting for the results.  Other interfaces can't be
handled automatically but <code class="xref py py-mod docutils literal notranslate"><span class="pre">Tkinter</span></code> will now raise an exception on such an
access so that you can at least find out about the problem.  See
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2002-December/031107.html">https://mail.python.org/pipermail/python-dev/2002-December/031107.html</a> for a more
detailed explanation of this change.  (Implemented by Martin von Löwis.)</p></li>
<li><p>Calling Tcl methods through <code class="xref py py-mod docutils literal notranslate"><span class="pre">_tkinter</span></code> no longer  returns only strings.
Instead, if Tcl returns other objects those objects are converted to their
Python equivalent, if one exists, or wrapped with a <code class="xref py py-class docutils literal notranslate"><span class="pre">_tkinter.Tcl_Obj</span></code>
object if no Python equivalent exists. This behavior can be controlled through
the <code class="xref py py-meth docutils literal notranslate"><span class="pre">wantobjects()</span></code> method of <code class="xref py py-class docutils literal notranslate"><span class="pre">tkapp</span></code> objects.</p>
<p>When using <code class="xref py py-mod docutils literal notranslate"><span class="pre">_tkinter</span></code> through the <code class="xref py py-mod docutils literal notranslate"><span class="pre">Tkinter</span></code> module (as most Tkinter
applications will), this feature is always activated. It should not cause
compatibility problems, since Tkinter would always convert string results to
Python types where possible.</p>
<p>If any incompatibilities are found, the old behavior can be restored by setting
the <code class="xref py py-attr docutils literal notranslate"><span class="pre">wantobjects</span></code> variable in the <code class="xref py py-mod docutils literal notranslate"><span class="pre">Tkinter</span></code> module to false before
creating the first <code class="xref py py-class docutils literal notranslate"><span class="pre">tkapp</span></code> object.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">Tkinter</span>
<span class="n">Tkinter</span><span class="o">.</span><span class="n">wantobjects</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Any breakage caused by this change should be reported as a bug.</p>
</li>
<li><p>The <code class="xref py py-mod docutils literal notranslate"><span class="pre">UserDict</span></code> module has a new <code class="xref py py-class docutils literal notranslate"><span class="pre">DictMixin</span></code> class which defines
all dictionary methods for classes that already have a minimum mapping
interface.  This greatly simplifies writing classes that need to be
substitutable for dictionaries, such as the classes in  the <a class="reference internal" href="../library/shelve.html#module-shelve" title="shelve: Python object persistence."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shelve</span></code></a>
module.</p>
<p>添加该混入类作为超类将在类定义了 <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__delitem__" title="object.__delitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delitem__()</span></code></a> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code> 的时候提供完整的字典接口。 例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">UserDict</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">SeqDict</span><span class="p">(</span><span class="n">UserDict</span><span class="o">.</span><span class="n">DictMixin</span><span class="p">):</span>
<span class="gp">... </span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Dictionary lookalike implemented with lists.&quot;&quot;&quot;</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">keylist</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">valuelist</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keylist</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">raise</span> <span class="ne">KeyError</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">valuelist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keylist</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="gp">... </span>            <span class="bp">self</span><span class="o">.</span><span class="n">valuelist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
<span class="gp">... </span>        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
<span class="gp">... </span>            <span class="bp">self</span><span class="o">.</span><span class="n">keylist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="gp">... </span>            <span class="bp">self</span><span class="o">.</span><span class="n">valuelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keylist</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">raise</span> <span class="ne">KeyError</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">keylist</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">valuelist</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keylist</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">SeqDict</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>      <span class="c1"># See that other dictionary methods are implemented</span>
<span class="go">[&#39;__cmp__&#39;, &#39;__contains__&#39;, &#39;__delitem__&#39;, &#39;__doc__&#39;, &#39;__getitem__&#39;,</span>
<span class="go"> &#39;__init__&#39;, &#39;__iter__&#39;, &#39;__len__&#39;, &#39;__module__&#39;, &#39;__repr__&#39;,</span>
<span class="go"> &#39;__setitem__&#39;, &#39;clear&#39;, &#39;get&#39;, &#39;has_key&#39;, &#39;items&#39;, &#39;iteritems&#39;,</span>
<span class="go"> &#39;iterkeys&#39;, &#39;itervalues&#39;, &#39;keylist&#39;, &#39;keys&#39;, &#39;pop&#39;, &#39;popitem&#39;,</span>
<span class="go"> &#39;setdefault&#39;, &#39;update&#39;, &#39;valuelist&#39;, &#39;values&#39;]</span>
</pre></div>
</div>
<p>（由 Raymond Hettinger 贡献。）</p>
</li>
<li><p>现在 <a class="reference internal" href="../library/xml.dom.minidom.html#module-xml.dom.minidom" title="xml.dom.minidom: Minimal Document Object Model (DOM) implementation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.dom.minidom</span></code></a> 中的 DOM 实现能够通过向 DOM 节点的 <a class="reference internal" href="../library/xml.dom.minidom.html#xml.dom.minidom.Node.toxml" title="xml.dom.minidom.Node.toxml"><code class="xref py py-meth docutils literal notranslate"><span class="pre">toxml()</span></code></a> 和 <a class="reference internal" href="../library/xml.dom.minidom.html#xml.dom.minidom.Node.toprettyxml" title="xml.dom.minidom.Node.toprettyxml"><code class="xref py py-meth docutils literal notranslate"><span class="pre">toprettyxml()</span></code></a> 方法提供可选的 encoding 参数以特定的编码格式生成 XML 输出。</p></li>
<li><p>The <code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpclib</span></code> module now supports an XML-RPC extension for handling nil
data values such as Python's <code class="docutils literal notranslate"><span class="pre">None</span></code>.  Nil values are always supported on
unmarshalling an XML-RPC response.  To generate requests containing <code class="docutils literal notranslate"><span class="pre">None</span></code>,
you must supply a true value for the <em>allow_none</em> parameter when creating a
<code class="xref py py-class docutils literal notranslate"><span class="pre">Marshaller</span></code> instance.</p></li>
<li><p>The new <code class="xref py py-mod docutils literal notranslate"><span class="pre">DocXMLRPCServer</span></code> module allows writing self-documenting XML-RPC
servers. Run it in demo mode (as a program) to see it in action.   Pointing the
web browser to the RPC server produces pydoc-style documentation; pointing
xmlrpclib to the server allows invoking the actual methods. (Contributed by
Brian Quinlan.)</p></li>
<li><p>Support for internationalized domain names (RFCs 3454, 3490, 3491, and 3492)
has been added. The &quot;idna&quot; encoding can be used to convert between a Unicode
domain name and the ASCII-compatible encoding (ACE) of that name.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="p">{}</span><span class="o">&gt;</span><span class="p">{}</span><span class="o">&gt;</span> <span class="sa">u</span><span class="s2">&quot;www.Alliancefrançaise.nu&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;idna&quot;</span><span class="p">)</span>
<span class="s1">&#39;www.xn--alliancefranaise-npb.nu&#39;</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> module has also been extended to transparently convert
Unicode hostnames to the ACE version before passing them to the C library.
Modules that deal with hostnames such as <code class="xref py py-mod docutils literal notranslate"><span class="pre">httplib</span></code> and <a class="reference internal" href="../library/ftplib.html#module-ftplib" title="ftplib: FTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ftplib</span></code></a>)
also support Unicode host names; <code class="xref py py-mod docutils literal notranslate"><span class="pre">httplib</span></code> also sends HTTP <code class="docutils literal notranslate"><span class="pre">Host</span></code>
headers using the ACE version of the domain name.  <a class="reference internal" href="../library/urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a> supports
Unicode URLs with non-ASCII host names as long as the <code class="docutils literal notranslate"><span class="pre">path</span></code> part of the URL
is ASCII only.</p>
<p>为实现此项更改，增加了 <a class="reference internal" href="../library/stringprep.html#module-stringprep" title="stringprep: String preparation, as per RFC 3453"><code class="xref py py-mod docutils literal notranslate"><span class="pre">stringprep</span></code></a> 模块，<code class="docutils literal notranslate"><span class="pre">mkstringprep</span></code> 工具以及 <code class="docutils literal notranslate"><span class="pre">punycode</span></code> 编码格式。</p>
</li>
</ul>
<section id="date-time-type">
<h3>Date/Time 类型<a class="headerlink" href="#date-time-type" title="Link to this heading">¶</a></h3>
<p>通过 <a class="reference internal" href="../library/datetime.html#module-datetime" title="datetime: Basic date and time types."><code class="xref py py-mod docutils literal notranslate"><span class="pre">datetime</span></code></a> 模块增加了适用于表示时间戳的日期和时间类型。 这些类型并不支持其他的历法或很多丰富的特性，只专注于简单地表示时间。</p>
<p>The three primary types are: <a class="reference internal" href="../library/datetime.html#datetime.date" title="datetime.date"><code class="xref py py-class docutils literal notranslate"><span class="pre">date</span></code></a>, representing a day, month, and year;
<a class="reference internal" href="../library/datetime.html#datetime.time" title="datetime.time"><code class="xref py py-class docutils literal notranslate"><span class="pre">time</span></code></a>, consisting of hour, minute, and second; and <a class="reference internal" href="../library/datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime</span></code></a>,
which contains all the attributes of both <a class="reference internal" href="../library/datetime.html#datetime.date" title="datetime.date"><code class="xref py py-class docutils literal notranslate"><span class="pre">date</span></code></a> and <a class="reference internal" href="../library/datetime.html#datetime.time" title="datetime.time"><code class="xref py py-class docutils literal notranslate"><span class="pre">time</span></code></a>.
There's also a <a class="reference internal" href="../library/datetime.html#datetime.timedelta" title="datetime.timedelta"><code class="xref py py-class docutils literal notranslate"><span class="pre">timedelta</span></code></a> class representing differences between two
points in time, and time zone logic is implemented by classes inheriting from
the abstract <a class="reference internal" href="../library/datetime.html#datetime.tzinfo" title="datetime.tzinfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">tzinfo</span></code></a> class.</p>
<p>You can create instances of <a class="reference internal" href="../library/datetime.html#datetime.date" title="datetime.date"><code class="xref py py-class docutils literal notranslate"><span class="pre">date</span></code></a> and <a class="reference internal" href="../library/datetime.html#datetime.time" title="datetime.time"><code class="xref py py-class docutils literal notranslate"><span class="pre">time</span></code></a> by either supplying
keyword arguments to the appropriate constructor, e.g.
<code class="docutils literal notranslate"><span class="pre">datetime.date(year=1972,</span> <span class="pre">month=10,</span> <span class="pre">day=15)</span></code>, or by using one of a number of
class methods.  For example, the <a class="reference internal" href="../library/datetime.html#datetime.date.today" title="datetime.date.today"><code class="xref py py-meth docutils literal notranslate"><span class="pre">today()</span></code></a> class method returns the
current local date.</p>
<p>Once created, instances of the date/time classes are all immutable. There are a
number of methods for producing formatted strings from objects:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">datetime</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">now</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span>
<span class="go">&#39;2002-12-30T21:27:03.994956&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">now</span><span class="o">.</span><span class="n">ctime</span><span class="p">()</span>  <span class="c1"># Only available on date, datetime</span>
<span class="go">&#39;Mon Dec 30 21:27:03 2002&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y </span><span class="si">%d</span><span class="s1"> %b&#39;</span><span class="p">)</span>
<span class="go">&#39;2002 30 Dec&#39;</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../library/datetime.html#datetime.datetime.replace" title="datetime.datetime.replace"><code class="xref py py-meth docutils literal notranslate"><span class="pre">replace()</span></code></a> method allows modifying one or more fields  of a
<a class="reference internal" href="../library/datetime.html#datetime.date" title="datetime.date"><code class="xref py py-class docutils literal notranslate"><span class="pre">date</span></code></a> or <a class="reference internal" href="../library/datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime</span></code></a> instance, returning a new instance:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">datetime.datetime(2002, 12, 30, 22, 15, 38, 827738)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">year</span><span class="o">=</span><span class="mi">2001</span><span class="p">,</span> <span class="n">hour</span> <span class="o">=</span> <span class="mi">12</span><span class="p">)</span>
<span class="go">datetime.datetime(2001, 12, 30, 12, 15, 38, 827738)</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Instances can be compared, hashed, and converted to strings (the result is the
same as that of <a class="reference internal" href="../library/datetime.html#datetime.datetime.isoformat" title="datetime.datetime.isoformat"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isoformat()</span></code></a>).  <a class="reference internal" href="../library/datetime.html#datetime.date" title="datetime.date"><code class="xref py py-class docutils literal notranslate"><span class="pre">date</span></code></a> and <a class="reference internal" href="../library/datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime</span></code></a>
instances can be subtracted from each other, and added to <a class="reference internal" href="../library/datetime.html#datetime.timedelta" title="datetime.timedelta"><code class="xref py py-class docutils literal notranslate"><span class="pre">timedelta</span></code></a>
instances.  The largest missing feature is that there's no standard library
support for parsing strings and getting back a <a class="reference internal" href="../library/datetime.html#datetime.date" title="datetime.date"><code class="xref py py-class docutils literal notranslate"><span class="pre">date</span></code></a> or
<a class="reference internal" href="../library/datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime</span></code></a>.</p>
<p>更多相关信息，请参阅模块的参考文档。 （由 Tim Peters 贡献。）</p>
</section>
<section id="the-optparse-module">
<h3>optparse 模块<a class="headerlink" href="#the-optparse-module" title="Link to this heading">¶</a></h3>
<p>The <a class="reference internal" href="../library/getopt.html#module-getopt" title="getopt: Portable parser for command line options; support both short and long option names."><code class="xref py py-mod docutils literal notranslate"><span class="pre">getopt</span></code></a> module provides simple parsing of command-line arguments.  The
new <a class="reference internal" href="../library/optparse.html#module-optparse" title="optparse: Command-line option parsing library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">optparse</span></code></a> module (originally named Optik) provides more elaborate
command-line parsing that follows the Unix conventions, automatically creates
the output for <code class="xref std std-option docutils literal notranslate"><span class="pre">--help</span></code>, and can perform different actions for different
options.</p>
<p>You start by creating an instance of <a class="reference internal" href="../library/optparse.html#optparse.OptionParser" title="optparse.OptionParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptionParser</span></code></a> and telling it what
your program's options are.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">optparse</span><span class="w"> </span><span class="kn">import</span> <span class="n">OptionParser</span>

<span class="n">op</span> <span class="o">=</span> <span class="n">OptionParser</span><span class="p">()</span>
<span class="n">op</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s1">&#39;-i&#39;</span><span class="p">,</span> <span class="s1">&#39;--input&#39;</span><span class="p">,</span>
              <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;string&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;input&#39;</span><span class="p">,</span>
              <span class="n">help</span><span class="o">=</span><span class="s1">&#39;set input filename&#39;</span><span class="p">)</span>
<span class="n">op</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s1">&#39;-l&#39;</span><span class="p">,</span> <span class="s1">&#39;--length&#39;</span><span class="p">,</span>
              <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;length&#39;</span><span class="p">,</span>
              <span class="n">help</span><span class="o">=</span><span class="s1">&#39;set maximum length of output&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Parsing a command line is then done by calling the <a class="reference internal" href="../library/optparse.html#optparse.OptionParser.parse_args" title="optparse.OptionParser.parse_args"><code class="xref py py-meth docutils literal notranslate"><span class="pre">parse_args()</span></code></a> method.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">options</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
<span class="nb">print</span> <span class="n">options</span>
<span class="nb">print</span> <span class="n">args</span>
</pre></div>
</div>
<p>This returns an object containing all of the option values, and a list of
strings containing the remaining arguments.</p>
<p>Invoking the script with the various arguments now works as you'd expect it to.
Note that the length argument is automatically converted to an integer.</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>./python<span class="w"> </span>opt.py<span class="w"> </span>-i<span class="w"> </span>data<span class="w"> </span>arg1
<span class="go">&lt;Values at 0x400cad4c: {&#39;input&#39;: &#39;data&#39;, &#39;length&#39;: None}&gt;</span>
<span class="go">[&#39;arg1&#39;]</span>
<span class="gp">$ </span>./python<span class="w"> </span>opt.py<span class="w"> </span>--input<span class="o">=</span>data<span class="w"> </span>--length<span class="o">=</span><span class="m">4</span>
<span class="go">&lt;Values at 0x400cad2c: {&#39;input&#39;: &#39;data&#39;, &#39;length&#39;: 4}&gt;</span>
<span class="go">[]</span>
<span class="gp">$</span>
</pre></div>
</div>
<p>The help message is automatically generated for you:</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>./python<span class="w"> </span>opt.py<span class="w"> </span>--help
<span class="go">usage: opt.py [options]</span>

<span class="go">options:</span>
<span class="go">  -h, --help            show this help message and exit</span>
<span class="go">  -iINPUT, --input=INPUT</span>
<span class="go">                        set input filename</span>
<span class="go">  -lLENGTH, --length=LENGTH</span>
<span class="go">                        set maximum length of output</span>
<span class="gp">$</span>
</pre></div>
</div>
<p>有关更多详细信息，请参见模块的文档。</p>
<p>Optik was written by Greg Ward, with suggestions from the readers of the Getopt
SIG.</p>
</section>
</section>
<section id="pymalloc-a-specialized-object-allocator">
<span id="section-pymalloc"></span><h2>Pymalloc: A Specialized Object Allocator<a class="headerlink" href="#pymalloc-a-specialized-object-allocator" title="Link to this heading">¶</a></h2>
<p>Pymalloc, a specialized object allocator written by Vladimir Marangozov, was a
feature added to Python 2.1.  Pymalloc is intended to be faster than the system
<code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> and to have less memory overhead for allocation patterns typical
of Python programs. The allocator uses C's <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> function to get large
pools of memory and then fulfills smaller memory requests from these pools.</p>
<p>In 2.1 and 2.2, pymalloc was an experimental feature and wasn't enabled by
default; you had to explicitly enable it when compiling Python by providing the
<code class="xref std std-option docutils literal notranslate"><span class="pre">--with-pymalloc</span></code> option to the <strong class="program">configure</strong> script.  In 2.3,
pymalloc has had further enhancements and is now enabled by default; you'll have
to supply <code class="xref std std-option docutils literal notranslate"><span class="pre">--without-pymalloc</span></code> to disable it.</p>
<p>This change is transparent to code written in Python; however, pymalloc may
expose bugs in C extensions.  Authors of C extension modules should test their
code with pymalloc enabled, because some incorrect code may cause core dumps at
runtime.</p>
<p>There's one particularly common error that causes problems.  There are a number
of memory allocation functions in Python's C API that have previously just been
aliases for the C library's <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> and <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code>, meaning that if
you accidentally called mismatched functions the error wouldn't be noticeable.
When the object allocator is enabled, these functions aren't aliases of
<code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> and <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code> any more, and calling the wrong function to
free memory may get you a core dump.  For example, if memory was allocated using
<a class="reference internal" href="../c-api/memory.html#c.PyObject_Malloc" title="PyObject_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Malloc()</span></code></a>, it has to be freed using <a class="reference internal" href="../c-api/memory.html#c.PyObject_Free" title="PyObject_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Free()</span></code></a>, not
<code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code>.  A few modules included with Python fell afoul of this and had to
be fixed; doubtless there are more third-party modules that will have the same
problem.</p>
<p>As part of this change, the confusing multiple interfaces for allocating memory
have been consolidated down into two API families. Memory allocated with one
family must not be manipulated with functions from the other family.  There is
one family for allocating chunks of memory and another family of functions
specifically for allocating Python objects.</p>
<ul class="simple">
<li><p>To allocate and free an undistinguished chunk of memory use the &quot;raw memory&quot;
family: <a class="reference internal" href="../c-api/memory.html#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code></a>, <a class="reference internal" href="../c-api/memory.html#c.PyMem_Realloc" title="PyMem_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Realloc()</span></code></a>, and <a class="reference internal" href="../c-api/memory.html#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Free()</span></code></a>.</p></li>
<li><p>The &quot;object memory&quot; family is the interface to the pymalloc facility described
above and is biased towards a large number of &quot;small&quot; allocations:
<a class="reference internal" href="../c-api/memory.html#c.PyObject_Malloc" title="PyObject_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Malloc()</span></code></a>, <a class="reference internal" href="../c-api/memory.html#c.PyObject_Realloc" title="PyObject_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Realloc()</span></code></a>, and <a class="reference internal" href="../c-api/memory.html#c.PyObject_Free" title="PyObject_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Free()</span></code></a>.</p></li>
<li><p>To allocate and free Python objects, use the &quot;object&quot; family
<a class="reference internal" href="../c-api/allocation.html#c.PyObject_New" title="PyObject_New"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyObject_New</span></code></a>, <a class="reference internal" href="../c-api/allocation.html#c.PyObject_NewVar" title="PyObject_NewVar"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyObject_NewVar</span></code></a>, and <a class="reference internal" href="../c-api/allocation.html#c.PyObject_Del" title="PyObject_Del"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Del()</span></code></a>.</p></li>
</ul>
<p>Thanks to lots of work by Tim Peters, pymalloc in 2.3 also provides debugging
features to catch memory overwrites and doubled frees in both extension modules
and in the interpreter itself.  To enable this support, compile a debugging
version of the Python interpreter by running <strong class="program">configure</strong> with
<code class="xref std std-option docutils literal notranslate"><span class="pre">--with-pydebug</span></code>.</p>
<p>To aid extension writers, a header file <code class="file docutils literal notranslate"><span class="pre">Misc/pymemcompat.h</span></code> is
distributed with the source to Python 2.3 that allows Python extensions to use
the 2.3 interfaces to memory allocation while compiling against any version of
Python since 1.5.2.  You would copy the file from Python's source distribution
and bundle it with the source of your extension.</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><a class="reference external" href="https://hg.python.org/cpython/file/default/Objects/obmalloc.c">https://hg.python.org/cpython/file/default/Objects/obmalloc.c</a></dt><dd><p>For the full details of the pymalloc implementation, see the comments at
the top of the file <code class="file docutils literal notranslate"><span class="pre">Objects/obmalloc.c</span></code> in the Python source code.
The above link points to the file within the python.org SVN browser.</p>
</dd>
</dl>
</div>
</section>
<section id="build-and-c-api-changes">
<h2>构建和 C API 的改变<a class="headerlink" href="#build-and-c-api-changes" title="Link to this heading">¶</a></h2>
<p>针对 Python 构建过程和 C API 的改变包括:</p>
<ul class="simple">
<li><p>The cycle detection implementation used by the garbage collection has proven
to be stable, so it's now been made mandatory.  You can no longer compile Python
without it, and the <code class="xref std std-option docutils literal notranslate"><span class="pre">--with-cycle-gc</span></code> switch to <strong class="program">configure</strong> has
been removed.</p></li>
<li><p>Python can now optionally be built as a shared library
(<code class="file docutils literal notranslate"><span class="pre">libpython2.3.so</span></code>) by supplying <code class="xref std std-option docutils literal notranslate"><span class="pre">--enable-shared</span></code> when running
Python's <strong class="program">configure</strong> script.  (Contributed by Ondrej Palkovsky.)</p></li>
<li><p>The <code class="xref c c-macro docutils literal notranslate"><span class="pre">DL_EXPORT</span></code> and <code class="xref c c-macro docutils literal notranslate"><span class="pre">DL_IMPORT</span></code> macros are now deprecated.
Initialization functions for Python extension modules should now be declared
using the new macro <a class="reference internal" href="../c-api/intro.html#c.PyMODINIT_FUNC" title="PyMODINIT_FUNC"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyMODINIT_FUNC</span></code></a>, while the Python core will
generally use the <code class="xref c c-macro docutils literal notranslate"><span class="pre">PyAPI_FUNC</span></code> and <code class="xref c c-macro docutils literal notranslate"><span class="pre">PyAPI_DATA</span></code> macros.</p></li>
<li><p>The interpreter can be compiled without any docstrings for the built-in
functions and modules by supplying <code class="xref std std-option docutils literal notranslate"><span class="pre">--without-doc-strings</span></code> to the
<strong class="program">configure</strong> script. This makes the Python executable about 10% smaller,
but will also mean that you can't get help for Python's built-ins.  (Contributed
by Gustavo Niemeyer.)</p></li>
<li><p>The <code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_NoArgs()</span></code> macro is now deprecated, and code that uses it
should be changed.  For Python 2.2 and later, the method definition table can
specify the <a class="reference internal" href="../c-api/structures.html#c.METH_NOARGS" title="METH_NOARGS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">METH_NOARGS</span></code></a> flag, signalling that there are no arguments,
and the argument checking can then be removed.  If compatibility with pre-2.2
versions of Python is important, the code could use <code class="docutils literal notranslate"><span class="pre">PyArg_ParseTuple(args,</span>
<span class="pre">&quot;&quot;)</span></code> instead, but this will be slower than using <a class="reference internal" href="../c-api/structures.html#c.METH_NOARGS" title="METH_NOARGS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">METH_NOARGS</span></code></a>.</p></li>
<li><p><a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> accepts new format characters for various sizes of
unsigned integers: <code class="docutils literal notranslate"><span class="pre">B</span></code> for <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span></span>, <code class="docutils literal notranslate"><span class="pre">H</span></code> for <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="kt">int</span></span>,  <code class="docutils literal notranslate"><span class="pre">I</span></code> for <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span></span>,  and <code class="docutils literal notranslate"><span class="pre">K</span></code> for <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span>.</p></li>
<li><p>A new function, <code class="docutils literal notranslate"><span class="pre">PyObject_DelItemString(mapping,</span> <span class="pre">char</span> <span class="pre">*key)</span></code> was added
as shorthand for <code class="docutils literal notranslate"><span class="pre">PyObject_DelItem(mapping,</span> <span class="pre">PyString_New(key))</span></code>.</p></li>
<li><p>File objects now manage their internal string buffer differently, increasing
it exponentially when needed.  This results in the benchmark tests in
<code class="file docutils literal notranslate"><span class="pre">Lib/test/test_bufio.py</span></code> speeding up considerably (from 57 seconds to 1.7
seconds, according to one measurement).</p></li>
<li><p>It's now possible to define class and static methods for a C extension type by
setting either the <a class="reference internal" href="../c-api/structures.html#c.METH_CLASS" title="METH_CLASS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">METH_CLASS</span></code></a> or <a class="reference internal" href="../c-api/structures.html#c.METH_STATIC" title="METH_STATIC"><code class="xref c c-macro docutils literal notranslate"><span class="pre">METH_STATIC</span></code></a> flags in a
method's <a class="reference internal" href="../c-api/structures.html#c.PyMethodDef" title="PyMethodDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMethodDef</span></code></a> structure.</p></li>
<li><p>Python now includes a copy of the Expat XML parser's source code, removing any
dependence on a system version or local installation of Expat.</p></li>
<li><p>If you dynamically allocate type objects in your extension, you should be
aware of a change in the rules relating to the <a class="reference internal" href="../reference/datamodel.html#type.__module__" title="type.__module__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code></a> and
<a class="reference internal" href="../reference/datamodel.html#type.__name__" title="type.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> attributes.  In summary, you will want to ensure the type's
dictionary contains a <code class="docutils literal notranslate"><span class="pre">'__module__'</span></code> key; making the module name the part of
the type name leading up to the final period will no longer have the desired
effect.  For more detail, read the API reference documentation or the  source.</p></li>
</ul>
<section id="port-specific-changes">
<h3>移植专属的改变<a class="headerlink" href="#port-specific-changes" title="Link to this heading">¶</a></h3>
<p>Support for a port to IBM's OS/2 using the EMX runtime environment was merged
into the main Python source tree.  EMX is a POSIX emulation layer over the OS/2
system APIs.  The Python port for EMX tries to support all the POSIX-like
capability exposed by the EMX runtime, and mostly succeeds; <code class="xref py py-func docutils literal notranslate"><span class="pre">fork()</span></code> and
<a class="reference internal" href="../library/fcntl.html#module-fcntl" title="fcntl: The fcntl() and ioctl() system calls. (Unix)"><code class="xref py py-func docutils literal notranslate"><span class="pre">fcntl()</span></code></a> are restricted by the limitations of the underlying emulation
layer.  The standard OS/2 port, which uses IBM's Visual Age compiler, also
gained support for case-sensitive import semantics as part of the integration of
the EMX port into CVS.  (Contributed by Andrew MacIntyre.)</p>
<p>On MacOS, most toolbox modules have been weaklinked to improve backward
compatibility.  This means that modules will no longer fail to load if a single
routine is missing on the current OS version. Instead calling the missing
routine will raise an exception. (Contributed by Jack Jansen.)</p>
<p>The RPM spec files, found in the <code class="file docutils literal notranslate"><span class="pre">Misc/RPM/</span></code> directory in the Python
source distribution, were updated for 2.3.  (Contributed by Sean Reifschneider.)</p>
<p>Other new platforms now supported by Python include AtheOS
(<a class="reference external" href="http://www.atheos.cx/">http://www.atheos.cx/</a>), GNU/Hurd, and OpenVMS.</p>
</section>
</section>
<section id="other-changes-and-fixes">
<span id="section-other"></span><h2>其他的改变和修正<a class="headerlink" href="#other-changes-and-fixes" title="Link to this heading">¶</a></h2>
<p>As usual, there were a bunch of other improvements and bugfixes scattered
throughout the source tree.  A search through the CVS change logs finds there
were 523 patches applied and 514 bugs fixed between Python 2.2 and 2.3.  Both
figures are likely to be underestimates.</p>
<p>一些较为重要的改变:</p>
<ul>
<li><p>If the <span class="target" id="index-28"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONINSPECT"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONINSPECT</span></code></a> environment variable is set, the Python
interpreter will enter the interactive prompt after running a Python program, as
if Python had been invoked with the <a class="reference internal" href="../using/cmdline.html#cmdoption-i"><code class="xref std std-option docutils literal notranslate"><span class="pre">-i</span></code></a> option. The environment
variable can be set before running the Python interpreter, or it can be set by
the Python program as part of its execution.</p></li>
<li><p>The <code class="file docutils literal notranslate"><span class="pre">regrtest.py</span></code> script now provides a way to allow &quot;all resources
except <em>foo</em>.&quot;  A resource name passed to the <code class="xref std std-option docutils literal notranslate"><span class="pre">-u</span></code> option can now be
prefixed with a hyphen (<code class="docutils literal notranslate"><span class="pre">'-'</span></code>) to mean &quot;remove this resource.&quot;  For example,
the option '<code class="docutils literal notranslate"><span class="pre">-uall,-bsddb</span></code>' could be used to enable the use of all resources
except <code class="docutils literal notranslate"><span class="pre">bsddb</span></code>.</p></li>
<li><p>The tools used to build the documentation now work under Cygwin as well as
Unix.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">SET_LINENO</span></code> opcode has been removed.  Back in the mists of time, this
opcode was needed to produce line numbers in tracebacks and support trace
functions (for, e.g., <a class="reference internal" href="../library/pdb.html#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pdb</span></code></a>). Since Python 1.5, the line numbers in
tracebacks have been computed using a different mechanism that works with
&quot;python -O&quot;.  For Python 2.3 Michael Hudson implemented a similar scheme to
determine when to call the trace function, removing the need for <code class="docutils literal notranslate"><span class="pre">SET_LINENO</span></code>
entirely.</p>
<p>It would be difficult to detect any resulting difference from Python code, apart
from a slight speed up when Python is run without <a class="reference internal" href="../using/cmdline.html#cmdoption-O"><code class="xref std std-option docutils literal notranslate"><span class="pre">-O</span></code></a>.</p>
<p>C extensions that access the <a class="reference internal" href="../reference/datamodel.html#frame.f_lineno" title="frame.f_lineno"><code class="xref py py-attr docutils literal notranslate"><span class="pre">f_lineno</span></code></a> field of frame objects should
instead call <code class="docutils literal notranslate"><span class="pre">PyCode_Addr2Line(f-&gt;f_code,</span> <span class="pre">f-&gt;f_lasti)</span></code>. This will have the
added effect of making the code work as desired under &quot;python -O&quot; in earlier
versions of Python.</p>
<p>A nifty new feature is that trace functions can now assign to the
<a class="reference internal" href="../reference/datamodel.html#frame.f_lineno" title="frame.f_lineno"><code class="xref py py-attr docutils literal notranslate"><span class="pre">f_lineno</span></code></a> attribute of frame objects, changing the line that will be
executed next.  A <code class="docutils literal notranslate"><span class="pre">jump</span></code> command has been added to the <a class="reference internal" href="../library/pdb.html#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pdb</span></code></a> debugger
taking advantage of this new feature. (Implemented by Richie Hindle.)</p>
</li>
</ul>
</section>
<section id="porting-to-python-2-3">
<h2>移植到 Python 2.3<a class="headerlink" href="#porting-to-python-2-3" title="Link to this heading">¶</a></h2>
<p>本节列出了先前描述的可能需要修改你的代码的改变：</p>
<ul>
<li><p>现在 <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 始终是一个关键字；如果它在你的代码中被用作变量名，则必须选择不同的名称。</p></li>
<li><p>对于字符串 <em>X</em> 和 <em>Y</em>，<code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">in</span> <span class="pre">Y</span></code> 现在当 <em>X</em> 长度超过一个字符时也是有效的。</p></li>
<li><p>现在 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> 类型构造器在字符串或浮点数因太大而无法以整数类型来容纳时将返回一个长整数而不是引发 <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a>。</p></li>
<li><p>If you have Unicode strings that contain 8-bit characters, you must declare
the file's encoding (UTF-8, Latin-1, or whatever) by adding a comment to the top
of the file.  See section <a class="reference internal" href="#section-encodings"><span class="std std-ref">PEP 263: 源代码的字符编码格式</span></a> for more information.</p></li>
<li><p>Calling Tcl methods through <code class="xref py py-mod docutils literal notranslate"><span class="pre">_tkinter</span></code> no longer  returns only strings.
Instead, if Tcl returns other objects those objects are converted to their
Python equivalent, if one exists, or wrapped with a <code class="xref py py-class docutils literal notranslate"><span class="pre">_tkinter.Tcl_Obj</span></code>
object if no Python equivalent exists.</p></li>
<li><p>Large octal and hex literals such as <code class="docutils literal notranslate"><span class="pre">0xffffffff</span></code> now trigger a
<a class="reference internal" href="../library/exceptions.html#FutureWarning" title="FutureWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FutureWarning</span></code></a>. Currently they're stored as 32-bit numbers and result in a
negative value, but in Python 2.4 they'll become positive long integers.</p>
<p>There are a few ways to fix this warning.  If you really need a positive number,
just add an <code class="docutils literal notranslate"><span class="pre">L</span></code> to the end of the literal.  If you're trying to get a 32-bit
integer with low bits set and have previously used an expression such as <code class="docutils literal notranslate"><span class="pre">~(1</span>
<span class="pre">&lt;&lt;</span> <span class="pre">31)</span></code>, it's probably clearest to start with all bits set and clear the
desired upper bits. For example, to clear just the top bit (bit 31), you could
write <code class="docutils literal notranslate"><span class="pre">0xffffffffL</span> <span class="pre">&amp;~(1L&lt;&lt;31)</span></code>.</p>
</li>
<li><p>You can no longer disable assertions by assigning to <code class="docutils literal notranslate"><span class="pre">__debug__</span></code>.</p></li>
<li><p>The Distutils <code class="xref py py-func docutils literal notranslate"><span class="pre">setup()</span></code> function has gained various new keyword arguments
such as <em>depends</em>.  Old versions of the Distutils will abort if passed unknown
keywords.  A solution is to check for the presence of the new
<code class="xref py py-func docutils literal notranslate"><span class="pre">get_distutil_options()</span></code> function in your <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> and only uses the
new keywords with a version of the Distutils that supports them:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">distutils</span><span class="w"> </span><span class="kn">import</span> <span class="n">core</span>

<span class="n">kw</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;sources&#39;</span><span class="p">:</span> <span class="s1">&#39;foo.c&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">}</span>
<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">core</span><span class="p">,</span> <span class="s1">&#39;get_distutil_options&#39;</span><span class="p">):</span>
    <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;depends&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;foo.h&#39;</span><span class="p">]</span>
<span class="n">ext</span> <span class="o">=</span> <span class="n">Extension</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>Using <code class="docutils literal notranslate"><span class="pre">None</span></code> as a variable name will now result in a <a class="reference internal" href="../library/exceptions.html#SyntaxWarning" title="SyntaxWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxWarning</span></code></a>
warning.</p></li>
<li><p>Names of extension types defined by the modules included with Python now
contain the module and a <code class="docutils literal notranslate"><span class="pre">'.'</span></code> in front of the type name.</p></li>
</ul>
</section>
<section id="acknowledgements">
<span id="acks"></span><h2>致谢<a class="headerlink" href="#acknowledgements" title="Link to this heading">¶</a></h2>
<p>作者感谢以下人员为本文的各种草案提供建议，更正和帮助： Jeff Bauer, Simon Brunning, Brett Cannon, Michael Chermside, Andrew Dalke, Scott David Daniels, Fred L. Drake, Jr., David Fraser,  Kelly Gerber, Raymond Hettinger, Michael Hudson, Chris Lambert, Detlef Lannert, Martin von Löwis, Andrew MacIntyre, Lalo Martins, Chad Netzer, Gustavo Niemeyer, Neal Norwitz, Hans Nowak, Chris Reedy, Francesco Ricciardi, Vinay Sajip, Neil Schemenauer, Roman Suzi, Jason Tishler, Just van Rossum.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#">Python 2.3 有什么新变化</a><ul>
<li><a class="reference internal" href="#pep-218-a-standard-set-datatype">PEP 218: 标准集合数据类型</a></li>
<li><a class="reference internal" href="#pep-255-simple-generators">PEP 255: 简单的生成器</a></li>
<li><a class="reference internal" href="#pep-263-source-code-encodings">PEP 263: 源代码的字符编码格式</a></li>
<li><a class="reference internal" href="#pep-273-importing-modules-from-zip-archives">PEP 273: 从ZIP压缩包导入模块</a></li>
<li><a class="reference internal" href="#pep-277-unicode-file-name-support-for-windows-nt">PEP 277: 针对 Windows NT 的 Unicode 文件名支持</a></li>
<li><a class="reference internal" href="#pep-278-universal-newline-support">PEP 278: 通用换行支持</a></li>
<li><a class="reference internal" href="#pep-279-enumerate">PEP 279: enumerate()</a></li>
<li><a class="reference internal" href="#pep-282-the-logging-package">PEP 282: logging 包</a></li>
<li><a class="reference internal" href="#pep-285-a-boolean-type">PEP 285: 布尔类型</a></li>
<li><a class="reference internal" href="#pep-293-codec-error-handling-callbacks">PEP 293: 编解码器错误处理回调</a></li>
<li><a class="reference internal" href="#pep-301-package-index-and-metadata-for-distutils">PEP 301: Distutils的软件包索引和元数据</a></li>
<li><a class="reference internal" href="#pep-302-new-import-hooks">PEP 302: 新导入钩子</a></li>
<li><a class="reference internal" href="#pep-305-comma-separated-files">PEP 305: 逗号分隔文件</a></li>
<li><a class="reference internal" href="#pep-307-pickle-enhancements">PEP 307：对 pickle 的改进</a></li>
<li><a class="reference internal" href="#extended-slices">扩展切片</a></li>
<li><a class="reference internal" href="#other-language-changes">其他语言特性修改</a><ul>
<li><a class="reference internal" href="#string-changes">字符串的改变</a></li>
<li><a class="reference internal" href="#optimizations">性能优化</a></li>
</ul>
</li>
<li><a class="reference internal" href="#new-improved-and-deprecated-modules">新增，改进和弃用的模块</a><ul>
<li><a class="reference internal" href="#date-time-type">Date/Time 类型</a></li>
<li><a class="reference internal" href="#the-optparse-module">optparse 模块</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pymalloc-a-specialized-object-allocator">Pymalloc: A Specialized Object Allocator</a></li>
<li><a class="reference internal" href="#build-and-c-api-changes">构建和 C API 的改变</a><ul>
<li><a class="reference internal" href="#port-specific-changes">移植专属的改变</a></li>
</ul>
</li>
<li><a class="reference internal" href="#other-changes-and-fixes">其他的改变和修正</a></li>
<li><a class="reference internal" href="#porting-to-python-2-3">移植到 Python 2.3</a></li>
<li><a class="reference internal" href="#acknowledgements">致谢</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一主题</h4>
    <p class="topless"><a href="2.4.html"
                          title="上一章">Python 2.4 有什么新变化</a></p>
  </div>
  <div>
    <h4>下一主题</h4>
    <p class="topless"><a href="2.2.html"
                          title="下一章">Python 2.2 有什么新变化</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/whatsnew/2.3.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="折叠边栏">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="2.2.html" title="Python 2.2 有什么新变化"
             >下一页</a> |</li>
        <li class="right" >
          <a href="2.4.html" title="Python 2.4 有什么新变化"
             >上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.14.0a4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python的新变化</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Python 2.3 有什么新变化</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q" id="search-box" />
          <input type="submit" value="提交" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="../copyright.html">
    
    版权所有
    
      </a>
     2001 Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
      See <a href="/license.html">History and License</a> for more information.<br />
    
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />
      最后更新于 2月 03, 2025 (05:36 UTC).
    
      <a href="/bugs.html">Found a bug</a>?
    
    <br />

    由 <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3创建。
    </div>

  </body>
</html>