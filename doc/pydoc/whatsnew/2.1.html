<!DOCTYPE html>

<html lang="zh-CN" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="Python 2.1 有什么新变化" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/whatsnew/2.1.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="作者, A.M. Kuchling,. 概述: 本文介绍了 Python 2.1 的新增特性。 虽然 2.1 的改变没有 Python 2.0 那么多，但是仍然有一些令人惊喜的东西。 2.1 是第一个使用 Python 增强提议，即 PEP 来进行引导的发行版，因此大部分重要的改变都有相应的 PEP 来提供有关改变的更完整文档和设计思路。 本文并未试图完整记录所有的新特性，而是为 Pytho..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="作者, A.M. Kuchling,. 概述: 本文介绍了 Python 2.1 的新增特性。 虽然 2.1 的改变没有 Python 2.0 那么多，但是仍然有一些令人惊喜的东西。 2.1 是第一个使用 Python 增强提议，即 PEP 来进行引导的发行版，因此大部分重要的改变都有相应的 PEP 来提供有关改变的更完整文档和设计思路。 本文并未试图完整记录所有的新特性，而是为 Pytho..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>Python 2.1 有什么新变化 &#8212; Python 3.14.0a4 文档</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=08c2cdb3" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=5349f25f" />
    
    <script src="../_static/documentation_options.js?v=495aad30"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=beaddf03"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.14.0a4 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于此文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权所有" href="../copyright.html" />
    <link rel="next" title="Python 2.0 有什么新变化" href="2.0.html" />
    <link rel="prev" title="Python 2.2 有什么新变化" href="2.2.html" />
    
      <script defer data-domain="docs.python.org" src="https://plausible.io/js/script.js"></script>
    
    <link rel="canonical" href="https://docs.python.org/3/whatsnew/2.1.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q" />
                <input type="submit" value="提交"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#">Python 2.1 有什么新变化</a><ul>
<li><a class="reference internal" href="#introduction">概述</a></li>
<li><a class="reference internal" href="#pep-227-nested-scopes">PEP 227: 嵌套的作用域</a></li>
<li><a class="reference internal" href="#pep-236-future-directives">PEP 236: __future__ 指令</a></li>
<li><a class="reference internal" href="#pep-207-rich-comparisons">PEP 207: 富比较</a></li>
<li><a class="reference internal" href="#pep-230-warning-framework">PEP 230: 警告框架</a></li>
<li><a class="reference internal" href="#pep-229-new-build-system">PEP 229: 新的构建系统</a></li>
<li><a class="reference internal" href="#pep-205-weak-references">PEP 205: 弱引用</a></li>
<li><a class="reference internal" href="#pep-232-function-attributes">PEP 232: 函数属性</a></li>
<li><a class="reference internal" href="#pep-235-importing-modules-on-case-insensitive-platforms">PEP 235: 在大小写不敏感的平台上导入模块</a></li>
<li><a class="reference internal" href="#pep-217-interactive-display-hook">PEP 217: 交互模式显示钩子</a></li>
<li><a class="reference internal" href="#pep-208-new-coercion-model">PEP 208: 新的强制转换模型</a></li>
<li><a class="reference internal" href="#pep-241-metadata-in-python-packages">PEP 241: Python 包中的元数据</a></li>
<li><a class="reference internal" href="#new-and-improved-modules">新增和改进的模块</a></li>
<li><a class="reference internal" href="#other-changes-and-fixes">其他的改变和修正</a></li>
<li><a class="reference internal" href="#acknowledgements">致谢</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一主题</h4>
    <p class="topless"><a href="2.2.html"
                          title="上一章">Python 2.2 有什么新变化</a></p>
  </div>
  <div>
    <h4>下一主题</h4>
    <p class="topless"><a href="2.0.html"
                          title="下一章">Python 2.0 有什么新变化</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/whatsnew/2.1.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="2.0.html" title="Python 2.0 有什么新变化"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="2.2.html" title="Python 2.2 有什么新变化"
             accesskey="P">上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.14.0a4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python的新变化</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Python 2.1 有什么新变化</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q" id="search-box" />
          <input type="submit" value="提交" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="what-s-new-in-python-2-1">
<h1>Python 2.1 有什么新变化<a class="headerlink" href="#what-s-new-in-python-2-1" title="Link to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">作者<span class="colon">:</span></dt>
<dd class="field-odd"><p>A.M. Kuchling</p>
</dd>
</dl>
<section id="introduction">
<h2>概述<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>本文介绍了 Python 2.1 的新增特性。 虽然 2.1 的改变没有 Python 2.0 那么多，但是仍然有一些令人惊喜的东西。 2.1 是第一个使用 Python 增强提议，即 PEP 来进行引导的发行版，因此大部分重要的改变都有相应的 PEP 来提供有关改变的更完整文档和设计思路。 本文并未试图完整记录所有的新特性，而是为 Python 程序员提供新特性的简单概览。 请参阅 Python 2.1 文档，或特定的 PEP，获取针对你感兴趣的任何新特性的更多细节。</p>
<p>Python 开发团队的一个近期目标是加速新发行版的步调，使得每 6 到 9 个月就有一个新发行版。 2.1 是基于这个新步调推出的第一个发行版，第一个内测版将于一月发布，即 2.0 最终版发布 3 个月之后。</p>
<p>Python 2.1 的最终版本于2001年4月17日发布。</p>
</section>
<section id="pep-227-nested-scopes">
<h2>PEP 227: 嵌套的作用域<a class="headerlink" href="#pep-227-nested-scopes" title="Link to this heading">¶</a></h2>
<p>Python 2.1 中的最大改变是 Python 的作用域规则。 在 Python 2.0 中，任意给定的时刻至多使用三个命名空间来查找变量名称：局部、模块和内置命名空间。 这往往会导致令人吃惊的结果因为它与人们直觉上的预期不相匹配。 例如，一个嵌套的递归函数将不起作用:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">():</span>
    <span class="o">...</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">g</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="n">g</span><span class="p">(</span><span class="n">value</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>函数 <code class="xref py py-func docutils literal notranslate"><span class="pre">g()</span></code> 总是会引发 <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> 异常，因为名称 <code class="docutils literal notranslate"><span class="pre">g</span></code> 的绑定既不在局部命名空间中也不在模块级命名空间中。 这在实践中不会有太大问题（你会经常这样递归地定义内部函数吗？），但是这也会让 <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> 表达式的使用更为笨拙，这在实践中是有问题的。 在使用了 <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> 的代码中你经常能发现局部变量通过作为参数的默认值被拷贝。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="s2">&quot;Return list of any entries equal to &#39;name&#39;&quot;</span>
    <span class="n">L</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="n">name</span><span class="p">,</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">list_attribute</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">L</span>
</pre></div>
</div>
<p>结果将会严重损害以高度函数式风格编写的 Python 代码的可读性。</p>
<p>Python 2.1 最显著的改变是增加了静态作用域这一语言特征来解决此问题。 作为它的第一项影响，在上述示例中的 <code class="docutils literal notranslate"><span class="pre">name=name</span></code> 默认参数现在将不再必要。 简单地说，当一个函数内部的给定变量名没有被赋值时（通过赋值语句，或者 <a class="reference internal" href="../reference/compound_stmts.html#def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">def</span></code></a>, <a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">class</span></code></a> 或 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句），对该变量的引用将在外层作用域的局部命名空间中查找。 对于该规则的更详细解释，以及具体实现的分析，请参阅相应的 PEP。</p>
<p>对于同时在模块层级和包含下层函数定义的函数内部局部变量使用了相同变量名的代码来说这项改变可能会导致一些兼容性问题。 不过这看来不太可能发生，因为阅读这样的代码本来就会相当令人困惑。</p>
<p>此项改变的一个附带影响是在特定条件下函数作用域内部 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> 和 <code class="docutils literal notranslate"><span class="pre">exec</span></code> 语句将不允许使用。 Python 参考手册已经写明 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> 仅在模块最高层级上是可用的，但此前 CPython 解释器从未强制实施此规则。 作为嵌套作用域具体实现的一部分，将 Python 源码转为字节码的编译器会生成不同的代码来访问某个包含作用域内的变量。 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> 和 <code class="docutils literal notranslate"><span class="pre">exec</span></code> 会使得编译器无法正确执行，因为它们会向局部命名空间添加在编译时还不存在的名称。 为此，如果一个函数包含带有自由变量的函数定义或 <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> 表达式，编译器将通过引发 <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> 异常来提示。</p>
<p>为了使前面的解释更清楚，下面是一个例子:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">():</span>
    <span class="c1"># 下一行有语法错误</span>
    <span class="n">exec</span> <span class="s1">&#39;x=2&#39;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">g</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">x</span>
</pre></div>
</div>
<p>包含 <code class="docutils literal notranslate"><span class="pre">exec</span></code> 语句的第 4 行有语法错误，因为 <code class="docutils literal notranslate"><span class="pre">exec</span></code> 会定义一个名为 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的新局部变量，它的值应当被 <code class="xref py py-func docutils literal notranslate"><span class="pre">g()</span></code> 所访问。</p>
<p>这应该不会是太大的限制，因为 <code class="docutils literal notranslate"><span class="pre">exec</span></code> 在多数 Python 代码中都极少被使用（而当它被使用时，往往也是个存在糟糕设计的信号）。</p>
<p>由于兼容性问题，嵌套作用域被逐步引入；在 Python 2.1 中，它们默认未启用，但可以通过在模块中使用 future 语句来开启，如 <span class="target" id="index-36"></span><a class="pep reference external" href="https://peps.python.org/pep-0236/"><strong>PEP 236</strong></a> 所述。 （参见下一节对 <span class="target" id="index-37"></span><a class="pep reference external" href="https://peps.python.org/pep-0236/"><strong>PEP 236</strong></a> 的进一步讨论。） 在 Python 2.2 中，嵌套作用域将成为默认设置，并且无法关闭，但用户将有整个 2.1 版本的生命周期来修复因引入嵌套作用域而导致的任何问题。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-38"></span><a class="pep reference external" href="https://peps.python.org/pep-0227/"><strong>PEP 227</strong></a> - 静态嵌套作用域</dt><dd><p>由 Jeremy Hylton 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-236-future-directives">
<h2>PEP 236: __future__ 指令<a class="headerlink" href="#pep-236-future-directives" title="Link to this heading">¶</a></h2>
<p>对嵌套作用域的反应引起了广泛关注，人们担心在 Python 2.1 版本发布时会破坏现有代码，强烈的反应促使 Python 开发者采取了更保守的策略。这个策略包括引入一种约定，在版本 N 中启用可选功能，该功能将在版本 N+1 中成为强制功能。</p>
<p>语法使用 <code class="docutils literal notranslate"><span class="pre">from...import</span></code> 语句，使用保留模块名 <a class="reference internal" href="../library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">__future__</span></code></a>。可以通过以下语句启用嵌套作用域:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">nested_scopes</span>
</pre></div>
</div>
<p>虽然它看起来像一个普通的 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句，但实际上并不是；关于此类 future 语句的位置有严格的规定。它们只能放在模块的顶部，必须位于任何 Python 代码或常规 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> 语句之前。这是因为这样的语句会影响 Python 字节码编译器解析代码和生成字节码的方式，因此它们必须在任何会生成字节码的语句之前出现。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-39"></span><a class="pep reference external" href="https://peps.python.org/pep-0236/"><strong>PEP 236</strong></a> - 回到 <a class="reference internal" href="../library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">__future__</span></code></a></dt><dd><p>由 Tim Peters 撰写，主要由 Jeremy Hylton 实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-207-rich-comparisons">
<h2>PEP 207: 富比较<a class="headerlink" href="#pep-207-rich-comparisons" title="Link to this heading">¶</a></h2>
<p>在早期版本中，Python 对用户定义类和扩展类型的比较操作支持相当简单。类可以实现一个 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__cmp__()</span></code> 方法，该方法接收两个类实例，并且只能返回 0 表示相等，或 +1 或 -1 表示不相等；该方法不能引发异常或返回布尔值以外的任何内容。Numeric Python 的用户经常发现这种模型太弱且受限，因为在 Numeric Python 所用的数字运算程序中，能够对两个矩阵进行逐元素比较更为有用，返回一个包含每个元素比较结果的矩阵。如果两个矩阵的大小不同，则比较必须能够引发异常以表示错误。</p>
<p>在 Python 2.1 中增加了富比较操作以支持这一需求。 Python 类现在可以单独重载 <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">==</span></code> 和 <code class="docutils literal notranslate"><span class="pre">!=</span></code> 中的每个操作。 新的魔术方法名称如下：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>运算</p></th>
<th class="head"><p>方法名称</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&lt;</span></code></p></td>
<td><p><a class="reference internal" href="../reference/datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&lt;=</span></code></p></td>
<td><p><a class="reference internal" href="../reference/datamodel.html#object.__le__" title="object.__le__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__le__()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&gt;</span></code></p></td>
<td><p><a class="reference internal" href="../reference/datamodel.html#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__gt__()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&gt;=</span></code></p></td>
<td><p><a class="reference internal" href="../reference/datamodel.html#object.__ge__" title="object.__ge__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ge__()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">==</span></code></p></td>
<td><p><a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">!=</span></code></p></td>
<td><p><a class="reference internal" href="../reference/datamodel.html#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ne__()</span></code></a></p></td>
</tr>
</tbody>
</table>
<p>（这些魔术方法是以对应的 Fortran 操作符命名的，如 <code class="docutils literal notranslate"><span class="pre">.LT.</span></code>、<code class="docutils literal notranslate"><span class="pre">.LE.</span></code> 等。 数值程序员几乎肯定对这些名称非常熟悉，并且会发现它们易于记忆。）</p>
<p>每个这样的魔术方法的形式都是 <code class="docutils literal notranslate"><span class="pre">method(self,</span> <span class="pre">other)</span></code>，其中 <code class="docutils literal notranslate"><span class="pre">self</span></code> 是操作符左侧的对象，而 <code class="docutils literal notranslate"><span class="pre">other</span></code> 是操作符右侧的对象。 例如，表达式 <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">&lt;</span> <span class="pre">B</span></code> 会调用 <code class="docutils literal notranslate"><span class="pre">A.__lt__(B)</span></code>。</p>
<p>这些魔术方法可以返回任何类型的值：布尔值、矩阵、列表或任何其他 Python 对象。或者，如果比较是不可能的、不一致的或没有意义的，它们也可以引发异常。</p>
<p>内置的 <code class="docutils literal notranslate"><span class="pre">cmp(A,B)</span></code> 函数可以使用富比较机制，现在接受一个可选参数来指定要使用的比较操作；该参数可以是字符串 <code class="docutils literal notranslate"><span class="pre">&quot;&lt;&quot;</span></code>、<code class="docutils literal notranslate"><span class="pre">&quot;&lt;=&quot;</span></code>、<code class="docutils literal notranslate"><span class="pre">&quot;&gt;&quot;</span></code>、<code class="docutils literal notranslate"><span class="pre">&quot;&gt;=&quot;</span></code>、<code class="docutils literal notranslate"><span class="pre">&quot;==&quot;</span></code> 或 <code class="docutils literal notranslate"><span class="pre">&quot;!=&quot;</span></code> 之一。 如果不带可选的第三个参数调用，<code class="xref py py-func docutils literal notranslate"><span class="pre">cmp()</span></code> 函数将只返回 -1、0 或 +1，就像以前的 Python 版本一样；否则，它将调用适当的方法并可以返回任何 Python 对象。</p>
<p>对于 C 程序员来说，也有相应的变更；类型对象中有一个新的槽位 <code class="docutils literal notranslate"><span class="pre">tp_richcmp</span></code> 以及一个用于执行指定富比较的 API。 这里我不会涉及 C API 的具体内容，完整的相关函数列表请参阅 <span class="target" id="index-40"></span><a class="pep reference external" href="https://peps.python.org/pep-0207/"><strong>PEP 207</strong></a> 或 2.1 的 C API 文档。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-41"></span><a class="pep reference external" href="https://peps.python.org/pep-0207/"><strong>PEP 207</strong></a> - 富比较</dt><dd><p>由 Guido van Rossum 编写，大量参考 David Ascher 的先期工作，并由 Guido van Rossum 实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-230-warning-framework">
<h2>PEP 230: 警告框架<a class="headerlink" href="#pep-230-warning-framework" title="Link to this heading">¶</a></h2>
<p>在过去的 10 年中，Python 积累了一定数量的过时模块和功能。 由于无法确切知道某个功能被使用的程度：可能没有程序依赖该功能，也可能有很多程序依赖，因此很难确定何时可以安全地移除某个功能，为了以更结构化的方式移除旧功能，添加了一个警告框架。 当 Python 开发者想要废弃某个功能时，它会在下一个 Python 版本中首先触发一个警告。 然后，在随后的Python版本中可以移除该功能，这样用户将有一个完整的发布周期来删除对旧功能的使用。</p>
<p>Python 2.1 增加了警告框架以用于此方案。 它增加了一个 <a class="reference internal" href="../library/warnings.html#module-warnings" title="warnings: Issue warning messages and control their disposition."><code class="xref py py-mod docutils literal notranslate"><span class="pre">warnings</span></code></a> 模块，该模块提供了发出警告的函数，以及过滤掉不想显示的警告的功能。 第三方模块也可以使用这个框架来弃用它们不再希望支持的旧功能。</p>
<p>例如，在 Python 2.1 中，<code class="xref py py-mod docutils literal notranslate"><span class="pre">regex</span></code> 模块已被弃用，因此导入它会打印出一个警告:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">regex</span>
<span class="go">__main__:1: DeprecationWarning: the regex module</span>
<span class="go">         is deprecated; please use the re module</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>警告可以通过调用 <a class="reference internal" href="../library/warnings.html#warnings.warn" title="warnings.warn"><code class="xref py py-func docutils literal notranslate"><span class="pre">warnings.warn()</span></code></a> 函数来发出:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;feature X no longer supported&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>第一个形参是警告消息；额外的可选形参可被用来指定一个专门的警告类别。</p>
<p>可以添加过滤器来禁用特定的警告；可以将某个正则表达式模式应用于消息或模块名称以抑制警告。 例如，你可能有一个使用 <code class="xref py py-mod docutils literal notranslate"><span class="pre">regex</span></code> 模块的程序但现在不想花时间将其转换为使用 <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 模块。 可以通过以下调用来抑制警告消息</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="n">action</span> <span class="o">=</span> <span class="s1">&#39;ignore&#39;</span><span class="p">,</span>
                        <span class="n">message</span><span class="o">=</span><span class="s1">&#39;.*regex module is deprecated&#39;</span><span class="p">,</span>
                        <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">,</span>
                        <span class="n">module</span> <span class="o">=</span> <span class="s1">&#39;__main__&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>这添加了一个过滤器，该过滤器仅适用于在 <a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where top-level code is run. Covers command-line interfaces, import-time behavior, and ``__name__ == '__main__'``."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a> 模块中触发的 <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-class docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a> 类警告，并应用一个正则表达式来仅匹配有关 <code class="xref py py-mod docutils literal notranslate"><span class="pre">regex</span></code> 模块已被弃用的消息，这将导致忽略此类警告。警告还可以仅打印一次，每次执行违规代码时打印，或者转换为异常，从而导致程序停止（当然，除非以常规方式捕获这些异常）。</p>
<p>Python 的 C API 也增加了用于发出警告的函数；详情请参阅 PEP 230 或 Python 的 API 文档。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-42"></span><a class="pep reference external" href="https://peps.python.org/pep-0005/"><strong>PEP 5</strong></a> - 语言演化的准则</dt><dd><p>该文档由 Paul Prescod 撰写，旨在规定移除 Python 旧功能时应遵循的程序。 尽管本文描述的政策尚未被正式采纳，但最终的政策可能不会与 Prescod 的提议有太大不同。</p>
</dd>
<dt><span class="target" id="index-43"></span><a class="pep reference external" href="https://peps.python.org/pep-0230/"><strong>PEP 230</strong></a> - 警告框架</dt><dd><p>由 Guido van Rossum 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-229-new-build-system">
<h2>PEP 229: 新的构建系统<a class="headerlink" href="#pep-229-new-build-system" title="Link to this heading">¶</a></h2>
<p>在编译 Python 时，用户必须进入并编辑 <code class="file docutils literal notranslate"><span class="pre">Modules/Setup</span></code> 文件以启用各种附加模块；默认集相对较小，并且仅限于在大多数 Unix 平台上编译的模块。这意味着在具有更多功能的 Unix 平台上，特别是 Linux，Python 安装通常不包含所有可能有用的模块。</p>
<p>Python 2.0 添加了 Distutils，一组用于分发和安装扩展模块的模块。在 Python 2.1 中，Distutils 被用于编译大部分标准库扩展模块，自动检测当前机器上支持哪些模块。希望这将使 Python 的安装更加容易并具有更多功能。</p>
<p>不再需要编辑 <code class="file docutils literal notranslate"><span class="pre">Modules/Setup</span></code> 文件来启用模块，而是在 Python 源代码分发包的顶层目录运行一个 <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> 脚本，该脚本在构建时尝试通过检查系统上的模块和头文件来发现可以启用那些模块。 如果某个模块已在 <code class="file docutils literal notranslate"><span class="pre">Modules/Setup</span></code> 中配置，则 <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> 脚本不会尝试编译该模块，并会遵从 <code class="file docutils literal notranslate"><span class="pre">Modules/Setup</span></code> 文件中的内容。 这提供了一种方式来指定特定平台所需的任何奇怪的命令行旗标或库。</p>
<p>在对构建机制的另一项重大更改中，Neil Schemenauer 对其进行了重组，现在 Python 使用单一的非递归 makefile，而不是在顶层目录和 <code class="file docutils literal notranslate"><span class="pre">Python/</span></code>、<code class="file docutils literal notranslate"><span class="pre">Parser/</span></code>、<code class="file docutils literal notranslate"><span class="pre">Objects/`和</span> <span class="pre">:file:`Modules/</span></code> 子目录中的多个 makefile。这使得构建 Python 更快，同时也使修改 Makefile 更加清晰和简单。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-44"></span><a class="pep reference external" href="https://peps.python.org/pep-0229/"><strong>PEP 229</strong></a> - 使用 Distutils 来构建 Python</dt><dd><p>由 A.M. Kuchling 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-205-weak-references">
<h2>PEP 205: 弱引用<a class="headerlink" href="#pep-205-weak-references" title="Link to this heading">¶</a></h2>
<p>弱引用，通过 <a class="reference internal" href="../library/weakref.html#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal notranslate"><span class="pre">weakref</span></code></a> 模块提供，是 Python 程序员工具箱中一种较小但有用的新数据类型。</p>
<p>存储一个指向对象的引用（例如，在字典或列表中）会导致该对象永久存活。 在某些特定情况下，这种行为是不符合需要的，最常见的是对象缓存，另一个是像树这样的数据结构中的循环引用。</p>
<p>例如，考虑一个记忆化函数，它通过将函数的参数及其结果存储在字典中来缓存另一个函数 <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> 的结果:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">_cache</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">def</span><span class="w"> </span><span class="nf">memoize</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">_cache</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_cache</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

    <span class="n">retval</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># 缓存返回的对象</span>
    <span class="n">_cache</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">retval</span>

    <span class="k">return</span> <span class="n">retval</span>
</pre></div>
</div>
<p>这个版本适用于诸如整数之类的简单对象，但它有一个副作用；<code class="docutils literal notranslate"><span class="pre">_cache</span></code> 字典持有返回值的引用，因此这些值在 Python 进程退出并清理之前永远不会被释放。 对于整数来说这不是很明显，但如果 <code class="xref py py-func docutils literal notranslate"><span class="pre">f()</span></code> 返回一个对象或占用大量内存的数据结构，这可能会成为一个问题。</p>
<p>弱引用提供了一种实现缓存的方法，不会让对象在其生命周期结束后仍然存活。 如果一个对象仅通过弱引用访问，该对象将被释放，并且弱引用将指示它所引用的对象不再存在。 通过调用 <code class="docutils literal notranslate"><span class="pre">wr</span> <span class="pre">=</span> <span class="pre">weakref.ref(obj)</span></code> 来创建对对象 <em>obj</em> 的弱引用。 通过调用弱引用，就像调用函数一样，可以返回被引用的对象: <code class="docutils literal notranslate"><span class="pre">wr()</span></code>。 如果对象仍然存在，它将返回被引用的对象；如果对象不再存在，则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p>这使得可以编写一个 <code class="xref py py-func docutils literal notranslate"><span class="pre">memoize()</span></code> 函数，其缓存不会使对象保持存活状态，因为缓存中存储的是弱引用。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">_cache</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">def</span><span class="w"> </span><span class="nf">memoize</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">_cache</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">_cache</span><span class="p">[</span><span class="n">x</span><span class="p">]()</span>
        <span class="c1"># 如果弱引用对象仍然存在，</span>
        <span class="c1"># 则返回它</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="n">obj</span>

    <span class="n">retval</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># 缓存一个弱引用</span>
    <span class="n">_cache</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">retval</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">retval</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/weakref.html#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal notranslate"><span class="pre">weakref</span></code></a> 模块还允许创建代理对象，代理对象的行为类似于弱引用 -- 仅被代理对象引用的对象会被解分配，但只要对象仍然存在，代理就会透明地将所有操作转发给对象，而不需要显式调用来检索对象。 如果对象已被解分配，尝试使用代理将引发 <code class="xref py py-exc docutils literal notranslate"><span class="pre">weakref.ReferenceError</span></code> 异常。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">proxy</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
<span class="n">proxy</span><span class="o">.</span><span class="n">attr</span>   <span class="c1"># 等同于 obj.attr</span>
<span class="n">proxy</span><span class="o">.</span><span class="n">meth</span><span class="p">()</span> <span class="c1"># 等同于 obj.meth()</span>
<span class="k">del</span> <span class="n">obj</span>
<span class="n">proxy</span><span class="o">.</span><span class="n">attr</span>   <span class="c1"># 引发 weakref.ReferenceError</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-45"></span><a class="pep reference external" href="https://peps.python.org/pep-0205/"><strong>PEP 205</strong></a> - 弱引用</dt><dd><p>由 Fred L. Drake, Jr 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-232-function-attributes">
<h2>PEP 232: 函数属性<a class="headerlink" href="#pep-232-function-attributes" title="Link to this heading">¶</a></h2>
<p>在 Python 2.1 中，函数现在可以附加任意信息。人们经常使用文档字符串来保存有关函数和方法的信息，因为 <a class="reference internal" href="../reference/datamodel.html#function.__doc__" title="function.__doc__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code></a> 属性是唯一可以将任何信息附加到函数上的方式。例如，在 Zope 网络应用服务器中，函数通过拥有文档字符串来标记为公共访问安全，在 John Aycock 的 SPARK 解析框架中，文档字符串包含要解析的 BNF 语法的部分。这种过载是不幸的，因为文档字符串实际上是用来保存函数文档的；例如，这意味着你不能正确地为 Zope 中预期用于私有用途的函数编写文档。</p>
<p>现在可以使用常规的 Python 语法在函数上设置和检索任意属性:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">():</span> <span class="k">pass</span>

<span class="n">f</span><span class="o">.</span><span class="n">publish</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">f</span><span class="o">.</span><span class="n">secure</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">f</span><span class="o">.</span><span class="n">grammar</span> <span class="o">=</span> <span class="s2">&quot;A ::= B (C D)*&quot;</span>
</pre></div>
</div>
<p>包含属性的字典可以作为函数的 <a class="reference internal" href="../reference/datamodel.html#function.__dict__" title="function.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 来访问。 与类实例的 <a class="reference internal" href="../reference/datamodel.html#type.__dict__" title="type.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 属性不同，在函数中你实际上可以为 <a class="reference internal" href="../reference/datamodel.html#function.__dict__" title="function.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 分配一个新的字典，尽管新值仅限于常规的 Python 字典；你 <em>不能</em> 狡猾地将其设为 <code class="xref py py-class docutils literal notranslate"><span class="pre">UserDict</span></code> 实例，或任何其他行为类似映射的随机对象。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-46"></span><a class="pep reference external" href="https://peps.python.org/pep-0232/"><strong>PEP 232</strong></a> - 函数属性</dt><dd><p>由 Barry Warsaw 撰写并实现</p>
</dd>
</dl>
</div>
</section>
<section id="pep-235-importing-modules-on-case-insensitive-platforms">
<h2>PEP 235: 在大小写不敏感的平台上导入模块<a class="headerlink" href="#pep-235-importing-modules-on-case-insensitive-platforms" title="Link to this heading">¶</a></h2>
<p>一些操作系统的文件系统是大小写不敏感的，MacOS 和 Windows 是主要的例子；在这些系统上，无法区分文件名 <code class="docutils literal notranslate"><span class="pre">FILE.PY</span></code> 和 <code class="docutils literal notranslate"><span class="pre">file.py</span></code>，尽管它们确实以原始大小写存储文件名（它们也是保留大小写的）。</p>
<p>在 Python 2.1 中，<a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句可以在不区分大小写的平台上模拟大小写敏感性。 现在，Python 默认搜索第一个大小写敏感匹配的文件，如果找不到这样的文件，就会引发 <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>，因此 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">file</span></code> 不会导入名为 <code class="docutils literal notranslate"><span class="pre">FILE.PY</span></code> 的模块。 在启动 Python 解释器之前，可以通过设置 <span class="target" id="index-47"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONCASEOK"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONCASEOK</span></code></a> 环境变量来请求大小写不敏感匹配。</p>
</section>
<section id="pep-217-interactive-display-hook">
<h2>PEP 217: 交互模式显示钩子<a class="headerlink" href="#pep-217-interactive-display-hook" title="Link to this heading">¶</a></h2>
<p>在交互模式下使用 Python 解释器时，命令的输出是通过内置的 <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 函数显示的。 在 Python 2.1 中，可以将变量 <a class="reference internal" href="../library/sys.html#sys.displayhook" title="sys.displayhook"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.displayhook()</span></code></a> 设置为一个可调用对象，该对象将在代替 <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 函数被调用。 例如，你可以将其设置为一个特殊的美化打印函数:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># 创建一个递归的数据结构</span>
<span class="gp">... </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="c1"># 显示 Python 的默认输出</span>
<span class="go">[1, 2, 3, [...]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 使用 pprint.pprint() 作为显示函数</span>
<span class="gp">... </span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span><span class="o">,</span><span class="w"> </span><span class="nn">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">displayhook</span> <span class="o">=</span> <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span>
<span class="go">[1, 2, 3,  &lt;Recursion on list with id=135143996&gt;]</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-48"></span><a class="pep reference external" href="https://peps.python.org/pep-0217/"><strong>PEP 217</strong></a> - 用于交互模式的显示钩子</dt><dd><p>由 Moshe Zadka 撰写并实现</p>
</dd>
</dl>
</div>
</section>
<section id="pep-208-new-coercion-model">
<h2>PEP 208: 新的强制转换模型<a class="headerlink" href="#pep-208-new-coercion-model" title="Link to this heading">¶</a></h2>
<p>在 C 级别上的数值类型转换方法进行了重大修改。 这只会影响编写 Python C 扩展的作者，使他们在编写支持数值运算的扩展类型时有更多的灵活性。</p>
<p>扩展类型现在可以在其 <code class="docutils literal notranslate"><span class="pre">PyTypeObject</span></code> 结构中设置类型标志 <code class="docutils literal notranslate"><span class="pre">Py_TPFLAGS_CHECKTYPES</span></code>，以表明它们支持新的强制模型。 在此类扩展类型中，数字槽函数不再假定它们将得到两个相同类型的参数；相反，它们可能会得到两个不同类型的参数，然后可以执行自己的内部强制。如果槽函数传递给它一个无法处理的类型，它可以通过返回一个指向 <code class="docutils literal notranslate"><span class="pre">Py_NotImplemented</span></code> 单一值的引用来表示失败。 然后将尝试其他类型的数值函数，也许它们可以处理该操作；如果其他类型也返回 <code class="docutils literal notranslate"><span class="pre">Py_NotImplemented</span></code>，那么将引发 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。 用 Python 写的数值方法也可以返回 <code class="docutils literal notranslate"><span class="pre">Py_NotImplemented</span></code>，导致解释器当作该方法不存在（也许会引发 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>，也许会尝试另一个对象的数值方法）。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-49"></span><a class="pep reference external" href="https://peps.python.org/pep-0208/"><strong>PEP 208</strong></a> - 改写强制转换模型</dt><dd><p>由 Neil Schemenauer 编写和实现，基于 Marc-André Lemburg 的早期工作。阅读这部分内容可以了解数值运算在 C 级别上现在如何处理的细节。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-241-metadata-in-python-packages">
<h2>PEP 241: Python 包中的元数据<a class="headerlink" href="#pep-241-metadata-in-python-packages" title="Link to this heading">¶</a></h2>
<p>Python 用户经常抱怨的一个问题是不存在包含所有 Python 模块的单一类目。 位于 <code class="docutils literal notranslate"><span class="pre">www.vex.net/parnassus/</span></code> 上 T. Middleton 的 Vaults of Parnassus (2009 年 2 月已停用，<a class="reference external" href="https://web.archive.org/web/20090130140102/http://www.vex.net/parnassus/">可在 Internet Archive Wayback Machine</a> 上查阅) 是最大的 Python 模块类目，但在 Vaults 上注册软件只是个可选项，很多人都懒得这样做。</p>
<p>作为解决这个问题的第一步，使用 Distutils <strong class="command">sdist</strong> 命令打包的 Python 软件将包含一个名为 <code class="file docutils literal notranslate"><span class="pre">PKG-INFO</span></code> 的文件，其中包含有关包的信息，如名称、版本和作者（在目录编制术语中称为元数据）。<code class="file docutils literal notranslate"><span class="pre">PKG-INFO</span></code> 文件可以包含的字段的完整列表见 <span class="target" id="index-50"></span><a class="pep reference external" href="https://peps.python.org/pep-0241/"><strong>PEP 241</strong></a>。随着人们开始使用 Python 2.1 打包他们的软件，越来越多的包将包含元数据，从而使得构建自动化目录系统并进行实验成为可能。通过积累经验，也许有可能设计一个真正好的目录系统，然后在 Python 2.2 中支持它。例如，Distutils 的 <strong class="command">sdist</strong> 和 <strong class="command">bdist_*</strong> 命令可以支持一个 <code class="docutils literal notranslate"><span class="pre">upload</span></code> 选项，自动将你的包上传到目录服务器。</p>
<p>即使你不使用 Python 2.1，你也可以开始创建包含 <code class="file docutils literal notranslate"><span class="pre">PKG-INFO</span></code> 的包，因为 Distutils 的新版本将为早期 Python 版本的用户发布。Distutils 1.0.2 版本包含了 <span class="target" id="index-51"></span><a class="pep reference external" href="https://peps.python.org/pep-0241/"><strong>PEP 241</strong></a> 所描述的更改，以及各种错误修复和增强功能。可以从 Distutils SIG 上获取该版本 <a class="reference external" href="https://www.python.org/community/sigs/current/distutils-sig/">https://www.python.org/community/sigs/current/distutils-sig/</a> 。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-52"></span><a class="pep reference external" href="https://peps.python.org/pep-0241/"><strong>PEP 241</strong></a> - 针对 Python 软件包的元数据</dt><dd><p>由 A.M. Kuchling 撰写并实现。</p>
</dd>
<dt><span class="target" id="index-53"></span><a class="pep reference external" href="https://peps.python.org/pep-0243/"><strong>PEP 243</strong></a> - 模块仓库上传机制</dt><dd><p>由 Sean Reifschneider 撰写，这个 PEP 草案描述了用于将 Python 软件包上传到一个中心服务器的建议机制。</p>
</dd>
</dl>
</div>
</section>
<section id="new-and-improved-modules">
<h2>新增和改进的模块<a class="headerlink" href="#new-and-improved-modules" title="Link to this heading">¶</a></h2>
<ul>
<li><p>Ka-Ping Yee 贡献了两个新模块: <code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect.py</span></code>，用于获取有关正在运行的 Python 代码的信息，以及 <code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc.py</span></code>，用于交互式地将文档字符串转换为 HTML 或文本。 此外，作为一个额外的功能，<code class="file docutils literal notranslate"><span class="pre">Tools/scripts/pydoc</span></code> 现在会自动安装，并使用 <code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc.py</span></code> 来显示给定 Python 模块、包或类名的文档。例如，<code class="docutils literal notranslate"><span class="pre">pydoc</span> <span class="pre">xml.dom</span></code> 会显示如下内容:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Python</span> <span class="n">Library</span> <span class="n">Documentation</span><span class="p">:</span> <span class="n">package</span> <span class="n">xml</span><span class="o">.</span><span class="n">dom</span> <span class="ow">in</span> <span class="n">xml</span>

<span class="n">NAME</span>
    <span class="n">xml</span><span class="o">.</span><span class="n">dom</span> <span class="o">-</span> <span class="n">W3C</span> <span class="n">Document</span> <span class="n">Object</span> <span class="n">Model</span> <span class="n">implementation</span> <span class="k">for</span> <span class="n">Python</span><span class="o">.</span>

<span class="n">FILE</span>
    <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">python2</span><span class="mf">.1</span><span class="o">/</span><span class="n">xml</span><span class="o">/</span><span class="n">dom</span><span class="o">/</span><span class="fm">__init__</span><span class="o">.</span><span class="n">pyc</span>

<span class="n">DESCRIPTION</span>
    <span class="n">The</span> <span class="n">Python</span> <span class="n">mapping</span> <span class="n">of</span> <span class="n">the</span> <span class="n">Document</span> <span class="n">Object</span> <span class="n">Model</span> <span class="ow">is</span> <span class="n">documented</span> <span class="ow">in</span> <span class="n">the</span>
    <span class="n">Python</span> <span class="n">Library</span> <span class="n">Reference</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">section</span> <span class="n">on</span> <span class="n">the</span> <span class="n">xml</span><span class="o">.</span><span class="n">dom</span> <span class="n">package</span><span class="o">.</span>

    <span class="n">This</span> <span class="n">package</span> <span class="n">contains</span> <span class="n">the</span> <span class="n">following</span> <span class="n">modules</span><span class="p">:</span>
      <span class="o">...</span>
</pre></div>
</div>
<p><code class="file docutils literal notranslate"><span class="pre">pydoc</span></code> 还包括一个基于 Tk 的交互式帮助浏览器。<code class="file docutils literal notranslate"><span class="pre">pydoc</span></code> 很快会让人上瘾；试试看！</p>
</li>
<li><p>两个不同的单元测试模块被添加到标准库中。<a class="reference internal" href="../library/doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> 模块，由 Tim Peters 贡献，提供了一个基于运行嵌入在文档字符串中的示例并将结果与预期输出进行比较的测试框架。PyUnit，由 Steve Purcell 贡献，是一个受到 JUnit 启发的单元测试框架，而 JUnit 则是对 Kent Beck 的 Smalltalk 测试框架的改编。更多关于 PyUnit 的信息，请参阅 <a class="reference external" href="https://pyunit.sourceforge.net/">https://pyunit.sourceforge.net/</a> 。</p></li>
<li><p><a class="reference internal" href="../library/difflib.html#module-difflib" title="difflib: Helpers for computing differences between objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">difflib</span></code></a> 模块包含一个类，即 <a class="reference internal" href="../library/difflib.html#difflib.SequenceMatcher" title="difflib.SequenceMatcher"><code class="xref py py-class docutils literal notranslate"><span class="pre">SequenceMatcher</span></code></a>，用于比较两个序列，并计算将一个序列转换为另一个序列所需的变化。 例如，该模块可用于编写与 Unix <strong class="program">diff</strong> 程序类似的工具，事实上，示例程序 <code class="file docutils literal notranslate"><span class="pre">Tools/scripts/ndiff.py</span></code> 演示了如何编写这样的脚本。</p></li>
<li><p><a class="reference internal" href="../library/curses.panel.html#module-curses.panel" title="curses.panel: A panel stack extension that adds depth to  curses windows."><code class="xref py py-mod docutils literal notranslate"><span class="pre">curses.panel</span></code></a>，是 ncurses 和 SYSV curses 一部分的 panel 库的包装器，由 Thomas Gellekum 贡献。panel 库为窗口提供了深度特性。窗口可以在深度顺序中向上或向下移动，panel 库会计算出面板的重叠位置和哪些部分是可见的。</p></li>
<li><p>PyXML 包自 Python 2.0 以来经历了几次发布，Python 2.1 包含了更新版本的 <a class="reference internal" href="../library/xml.html#module-xml" title="xml: Package containing XML processing modules"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml</span></code></a> 包。一些值得注意的更改包括支持 Expat 1.2 及更高版本，Expat 解析器能够处理 Python 支持的任何编码的文件，以及对 SAX、DOM 和 <code class="xref py py-mod docutils literal notranslate"><span class="pre">minidom</span></code> 模块的各种错误修复。</p></li>
<li><p>Ka-Ping Yee 还贡献了另一个用于处理未捕获异常的钩子。<a class="reference internal" href="../library/sys.html#sys.excepthook" title="sys.excepthook"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.excepthook()</span></code></a> 可以设置为一个可调用对象。当异常未被任何 <a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>...<a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> 块捕获时，异常将传递给 <a class="reference internal" href="../library/sys.html#sys.excepthook" title="sys.excepthook"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.excepthook()</span></code></a>，它可以执行任何需要的操作。在第九届 Python 会议上，他演示了这个钩子的一个应用：打印扩展的回溯信息，不仅列出堆栈帧，还列出每个帧的函数参数和局部变量。</p></li>
<li><p><a class="reference internal" href="../library/time.html#module-time" title="time: Time access and conversions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">time</span></code></a> 模块中的各种函数，如 <a class="reference internal" href="../library/time.html#time.asctime" title="time.asctime"><code class="xref py py-func docutils literal notranslate"><span class="pre">asctime()</span></code></a> 和 <a class="reference internal" href="../library/time.html#time.localtime" title="time.localtime"><code class="xref py py-func docutils literal notranslate"><span class="pre">localtime()</span></code></a>，需要一个包含自纪元以来的时间以秒为单位的浮点参数。这些函数最常见的用途是处理当前时间，因此浮点参数现在是可选的；当没有提供值时，将使用当前时间。例如，日志文件条目通常需要一个包含当前时间的字符串；在 Python 2.1 中，可以使用 <code class="docutils literal notranslate"><span class="pre">time.asctime()</span></code>，而不是之前需要的较长的 <code class="docutils literal notranslate"><span class="pre">time.asctime(time.localtime(time.time()))</span></code>。</p>
<p>此更改由 Thomas Wouters 提出并实现。</p>
</li>
<li><p><a class="reference internal" href="../library/ftplib.html#module-ftplib" title="ftplib: FTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ftplib</span></code></a> 模块现在默认以被动模式检索文件，因为被动模式在防火墙后面更可能正常工作。这一请求来自 Debian 错误跟踪系统，因为其他 Debian 包使用 <a class="reference internal" href="../library/ftplib.html#module-ftplib" title="ftplib: FTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ftplib</span></code></a> 来检索文件，但在防火墙后面无法正常工作。由于 Netscape 默认使用被动模式且几乎没有人抱怨，因此认为这不太可能会对任何人造成问题。但如果被动模式不适合你的应用程序或网络设置，可以调用 FTP 对象的 <code class="docutils literal notranslate"><span class="pre">set_pasv(0)</span></code> 来禁用被动模式。</p></li>
<li><p>对原始套接字访问的支持已添加到 <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> 模块中，由 Grant Edwards 贡献。</p></li>
<li><p><a class="reference internal" href="../library/profile.html#module-pstats" title="pstats: Statistics object for use with the profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pstats</span></code></a> 模块现在包含一个简单的交互式统计浏览器，用于显示 Python 程序的时间分析结果，当该模块作为脚本运行时调用。此功能由 Eric S. Raymond 贡献。</p></li>
<li><p>新增了一个依赖于实现的函数 <code class="docutils literal notranslate"><span class="pre">sys._getframe([depth])</span></code>，用于从当前调用堆栈中返回给定的帧对象。<code class="xref py py-func docutils literal notranslate"><span class="pre">sys._getframe`返回调用堆栈顶部的帧对象；如果提供了可选的整数参数</span> <span class="pre">depth，则该函数返回堆栈顶部以下</span> <span class="pre">depth</span> <span class="pre">层的帧。例如，``sys._getframe(1)`()</span></code> 返回调用者的帧对象。</p>
<p>这个函数仅存在于 CPython 中，不存在于 Jython 或 .NET 实现中。请将其用于调试，并避免将其放入生产代码中。</p>
</li>
</ul>
</section>
<section id="other-changes-and-fixes">
<h2>其他的改变和修正<a class="headerlink" href="#other-changes-and-fixes" title="Link to this heading">¶</a></h2>
<p>由于较短的发布周期，Python 2.1 中的较小更改相对较少。通过搜索 CVS 更改日志，发现应用了 117 个补丁并修复了 136 个错误；这两个数字都可能是低估的。一些较为显著的更改包括：</p>
<ul>
<li><p>现在可以选择使用一个专门的对象分配器，该分配器应比系统的 <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> 更快且具有更少的内存开销。该分配器使用 C 语言的 <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> 函数来获取大型内存池，然后从这些池中满足较小的内存请求。可以通过向 <strong class="program">configure</strong> 脚本提供 <code class="xref std std-option docutils literal notranslate"><span class="pre">--with-pymalloc</span></code> 选项来启用该分配器；有关实现细节，请参阅 <code class="file docutils literal notranslate"><span class="pre">Objects/obmalloc.c</span></code>。</p>
<p>C 扩展模块的作者应该在启用对象分配器的情况下测试他们的代码，因为一些不正确的代码可能会被破坏，导致运行时的核心转储。 在 Python 的 C API 中有许多内存分配函数，它们以前只是 C 库的 <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> 和 <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code> 的别名，这意味着如果您不小心调用了不匹配的函数，错误是不会被注意到的。 启用对象分配器后，这些函数不再是 <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> 和 <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code> 的别名，调用错误的函数释放内存将导致核心转储。 例如，如果使用 <a class="reference internal" href="../c-api/memory.html#c.PyMem_New" title="PyMem_New"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyMem_New</span></code></a> 分配了内存，就必须使用 <a class="reference internal" href="../c-api/memory.html#c.PyMem_Del" title="PyMem_Del"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Del()</span></code></a> 而不是 <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code> 释放内存。 Python 附带的一些模块就有这样的问题，必须进行修复；毫无疑问，还有更多的第三方模块会有同样的问题。</p>
<p>对象分配器由 Vladimir Marangozov 贡献。</p>
</li>
<li><p>由于人们经常抱怨面向行的文件 I/O 速度缓慢，并且它经常被用作一个简单的基准测试，其速度已经得到了改进。 因此，文件对象的 <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a> 方法被重写，以实现更快的速度。 具体的速度提升因平台而异，取决于 C 库的 <code class="xref c c-func docutils literal notranslate"><span class="pre">getc()</span></code> 有多慢，但大约提升了66%，在某些特定的操作系统上可能更快。 Tim Peters 在 comp.lang.python 的讨论中受到了启发，进行了许多基准测试和编码修改。</p>
<p>新增了一个模块和文件对象的方法，由 Jeff Epler 贡献。 新方法 <code class="xref py py-meth docutils literal notranslate"><span class="pre">xreadlines()</span></code> 类似于现有的内置方法 <code class="xref py py-func docutils literal notranslate"><span class="pre">xrange()</span></code>。 <code class="xref py py-func docutils literal notranslate"><span class="pre">xreadlines()</span></code> 返回一个不透明的序列对象，该对象仅支持迭代，每次迭代读取一行，而不像现有的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">readlines()</span></code> 方法那样将整个文件读入内存。 你可以像这样使用它:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">xreadlines</span><span class="p">():</span>
    <span class="c1"># ... 对每一行执行某些操作 ...</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>有关行 I/O 更改的更详细讨论，请参阅 2001 年 1 月 1 日至 15 日的 python-dev 摘要 <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2001-January/">https://mail.python.org/pipermail/python-dev/2001-January/</a> 。</p>
</li>
<li><p>给字典添加了一个新方法 <a class="reference internal" href="../library/stdtypes.html#dict.popitem" title="dict.popitem"><code class="xref py py-meth docutils literal notranslate"><span class="pre">popitem()</span></code></a>，用于破坏性地迭代字典的内容；这对于大字典来说可能更快，因为不需要构建包含所有键或值的列表。 <code class="docutils literal notranslate"><span class="pre">D.popitem()</span></code> 从字典``D``中移除一个随机的``(key, value)``键值对，并将其作为一个 2 元组返回。 此功能主要由 Tim Peters 和 Guido van Rossum 实现，基于 Moshe Zadka 的建议和初步补丁。</p></li>
<li><p>模块现在可以通过定义一个 <code class="docutils literal notranslate"><span class="pre">__all__</span></code> 属性来控制使用 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> 时导入的名称。 一个常见的抱怨是，如果模块导入了其他模块，例如 <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a> 或 <a class="reference internal" href="../library/string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code></a>，使用 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> 会将它们添加到导入模块的命名空间中。 为了解决这个问题，只需在 <code class="docutils literal notranslate"><span class="pre">__all__</span></code> 模块中列出公共名称即可:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 列出公有名称</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Database&#39;</span><span class="p">,</span> <span class="s1">&#39;open&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>此补丁的更严格版本最初由 Ben Wolfson 提出并实现，但在经过一些 python-dev 讨论后，最终版本被修改为较弱的版本并提交。</p>
</li>
<li><p>以前对字符串应用 <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 时，对于不可打印字符使用八进制转义符；例如，换行符表示为 <code class="docutils literal notranslate"><span class="pre">'\012'</span></code>。这是 Python 从 C 语言继承而来的遗留特性，但如今八进制的实际用途非常有限。Ka-Ping Yee 建议使用十六进制转义符代替八进制，并使用 <code class="docutils literal notranslate"><span class="pre">\n</span></code>、<code class="docutils literal notranslate"><span class="pre">\t</span></code>、<code class="docutils literal notranslate"><span class="pre">\r</span></code> 等转义符表示适当的字符，并实现了这种新的格式。</p></li>
<li><p>在编译时检测到的语法错误现在可以引发包含错误文件名和行号的异常，这是 Jeremy Hylton 进行的编译器重组的一个令人愉快的副作用。</p></li>
<li><p>导入其他模块的 C 扩展已更改为使用 <a class="reference internal" href="../c-api/import.html#c.PyImport_ImportModule" title="PyImport_ImportModule"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_ImportModule()</span></code></a>，这意味着它们将使用已安装的任何导入钩子。这对于需要从 C 代码导入其他模块的第三方扩展也同样鼓励使用。</p></li>
<li><p>由于 Fredrik Lundh 的努力，Unicode 字符数据库的大小又减少了 340K。</p></li>
<li><p>一些新移植版本被贡献：MacOS X（由 Steven Majewski 贡献），Cygwin（由 Jason Tishler 贡献），RISCOS（由 Dietmar Schwertberger 贡献），以及 Unixware 7（由 Billy G. Allie 贡献）。</p></li>
</ul>
<p>此外还有一份由次要的程序错误修复、次要的内存泄漏、文档字符串编辑和其他调整组成的常规清单，因过于冗长而不值得逐项列出；如果你想了解完整细节请参阅 CVS 日志。</p>
</section>
<section id="acknowledgements">
<h2>致谢<a class="headerlink" href="#acknowledgements" title="Link to this heading">¶</a></h2>
<p>作者感谢以下人员对本文的各种草案提出建议： Graeme Cross, David Goodger, Jay Graves, Michael Hudson, Marc-André Lemburg, Fredrik Lundh, Neil Schemenauer, Thomas Wouters.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#">Python 2.1 有什么新变化</a><ul>
<li><a class="reference internal" href="#introduction">概述</a></li>
<li><a class="reference internal" href="#pep-227-nested-scopes">PEP 227: 嵌套的作用域</a></li>
<li><a class="reference internal" href="#pep-236-future-directives">PEP 236: __future__ 指令</a></li>
<li><a class="reference internal" href="#pep-207-rich-comparisons">PEP 207: 富比较</a></li>
<li><a class="reference internal" href="#pep-230-warning-framework">PEP 230: 警告框架</a></li>
<li><a class="reference internal" href="#pep-229-new-build-system">PEP 229: 新的构建系统</a></li>
<li><a class="reference internal" href="#pep-205-weak-references">PEP 205: 弱引用</a></li>
<li><a class="reference internal" href="#pep-232-function-attributes">PEP 232: 函数属性</a></li>
<li><a class="reference internal" href="#pep-235-importing-modules-on-case-insensitive-platforms">PEP 235: 在大小写不敏感的平台上导入模块</a></li>
<li><a class="reference internal" href="#pep-217-interactive-display-hook">PEP 217: 交互模式显示钩子</a></li>
<li><a class="reference internal" href="#pep-208-new-coercion-model">PEP 208: 新的强制转换模型</a></li>
<li><a class="reference internal" href="#pep-241-metadata-in-python-packages">PEP 241: Python 包中的元数据</a></li>
<li><a class="reference internal" href="#new-and-improved-modules">新增和改进的模块</a></li>
<li><a class="reference internal" href="#other-changes-and-fixes">其他的改变和修正</a></li>
<li><a class="reference internal" href="#acknowledgements">致谢</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一主题</h4>
    <p class="topless"><a href="2.2.html"
                          title="上一章">Python 2.2 有什么新变化</a></p>
  </div>
  <div>
    <h4>下一主题</h4>
    <p class="topless"><a href="2.0.html"
                          title="下一章">Python 2.0 有什么新变化</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/whatsnew/2.1.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="折叠边栏">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="2.0.html" title="Python 2.0 有什么新变化"
             >下一页</a> |</li>
        <li class="right" >
          <a href="2.2.html" title="Python 2.2 有什么新变化"
             >上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.14.0a4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python的新变化</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Python 2.1 有什么新变化</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q" id="search-box" />
          <input type="submit" value="提交" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="../copyright.html">
    
    版权所有
    
      </a>
     2001 Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
      See <a href="/license.html">History and License</a> for more information.<br />
    
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />
      最后更新于 2月 03, 2025 (05:36 UTC).
    
      <a href="/bugs.html">Found a bug</a>?
    
    <br />

    由 <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3创建。
    </div>

  </body>
</html>